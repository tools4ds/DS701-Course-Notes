---
title: 'Essential Tools: Pandas'
jupyter: python3
code-fold: false
---

::: {.content-visible when-profile="web"}
## Introduction

[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/02B-Pandas.ipynb)

In this lecture we discuss one of most useful Python packages for data 
science -- Pandas.

We'll touch on some highlights here, but to learn more, start with the
[Pandas Getting started tutorials](https://pandas.pydata.org/docs/getting_started/intro_tutorials/index.html)
:::

## Pandas

::: {.incremental}

- [Pandas](https://pandas.pydata.org/docs/index.html) is a Python library for data
manipulation and analysis with an emphasis on tabular data. 
- It can be used to produce high quality plots and integrates nicely with other
  libraries that expect NumPy arrays. 
- Knowledge and use of Pandas is essential as a data scientist.
:::

:::: {.fragment}
The most important data structure provided by Pandas is the `DataFrame`
implemented in the 
[DataFrame](https://pandas.pydata.org/docs/reference/frame.html) class. 
::::

:::: {.fragment}
Unlike a numpy array, a `DataFrame` can have columns of different types.
::::

:::: {.fragment}
Make it a habit that when you're given a tabular dataset, load it into a `DataFrame`.
::::

## Fetching, storing and retrieving your data

We'll work with stock data. A popular python package for this is `yfinance`, but
there seems to be some access rate limits which make it more difficult to use.

Instead we'll manually download a CSV file:

    MANUAL DOWNLOAD FROM WALL STREET JOURNAL:
    
    1. Go to: https://www.wsj.com/market-data/quotes/NVDA/historical-prices
    2. Set date range: January 1, 2024 to December 31, 2024
    3. Click "Download" button
    4. Save the CSV file
    5. Load in Python:

```{python}
import pandas as pd

try:
    nvidia_stocks = pd.read_csv('data/stocks/nvidia_stock_2024.csv', index_col=0)
except FileNotFoundError:
    url = 'https://raw.githubusercontent.com/tools4ds/DS701-Course-Notes/main/ds701_book/data/stocks/nvidia_stock_2024.csv'
    nvidia_stocks = pd.read_csv(url, index_col=0)

nvidia_stocks = nvidia_stocks.sort_index()
```


---

It's important to inspect the data you are working with and Pandas provides a
variety of methods to do so such as `.head()`, `.tail()`, `.info()`,
`.describe()`, etc.

```{python}
#| code-fold: false
nvidia_stocks.head()
```


Notice how each row has a label and each column has a label.

---

A DataFrame is a python object that has many associated methods to explore and
manipulate the data.

The method `.info()` gives you a description of the dataframe.

```{python}
nvidia_stocks.info()
```

---

The method `.describe()` gives you summary statistics of the dataframe.

```{python}
nvidia_stocks.describe()
```

## Writing/Reading to/from a ``.csv`` file

Pandas can read and write dataframes with many file formats such as `.csv`, `.json`, `.parquet`,
`.xlsx`, `.html`, `SQL`, etc.

Here we write the dataframe to a `.csv` file.

```{python}
nvidia_stocks.to_csv('nvidia_data.csv')
```

We can escape a shell command using the `!` operator to see the top of the file.

```{python}
!head nvidia_data.csv
```

---

And of course we can likewise read a `.csv` file into a dataframe.  This is probably the most common way you will get data into Pandas.

```{python}
df = pd.read_csv('nvidia_data.csv')
df.head()
```

::: {.callout-caution}
But be careful, the index column is not automatically set.
:::

```{python}
df.info()
```

Note the index description.

---

To set the index column, we can use the `index_col` parameter.

```{python}
df = pd.read_csv('nvidia_data.csv', index_col=0)
df.info()
```

## Working with data columns

In general, we'll typically describe the rows in the dataframe as **items** 
(or **observations** or **data samples**) and the columns as **features**.

```{python}
df.columns
```

Pandas allows you to reference a column similar to a python dictionary key,
using column names in square brackets.

```{python}
df['Open']
```

Note that this returns a `Series` object, the other fundamental data structure in Pandas.

```{python}
type(df['Open'])
```

Also note that Series is indexed in this case by dates rather than simple integers.

---

Pandas also allows you to refer to columns using an object attribute syntax.

Note that the column name cannot include a space in this case.

```{python}
df.Open
```

---

You can select a list of columns:

```{python}
df[['Open', 'Close']].head()
```

Which is just another dataframe, which is why we can chain the `.head()` method.

```{python}
type(df[['Open', 'Close']])
```

---

Changing column names is as simple as assigning to the `.columns` property.

Let's adjust the column names to remove spaces.

```{python}
new_column_names = [x.lower().replace(' ', '_') for x in df.columns]
df.columns = new_column_names
df.info()
```

Observe that we first created a list of column names without spaces using __list comprehension__. This is the pythonic way to generate a new list.

Now **all** columns can be accessed using the **dot** notation.


## A sampling of DataFrame methods.

There are many useful methods in the DataFrame object. It is important to
familiarize yourself with these methods.

The following methods calculate the mean, standard deviation, and median of the specified numeric columns.

```{python}
df.mean()
```

or we can give a list of columns to the Dataframe object:

```{python}
df[['open', 'close', 'volume']].mean()
```

```{python}
df.std()
```

```{python}
df.median()
```

Or apply the method to a single column:

```{python}
df.open.mean()
```

```{python}
df.high.mean()
```

## Plotting methods

Pandas also wraps `matplotlib` and provides a variety of easy-to-use plotting
functions directly from the dataframe object.

These are your "first look" functions and useful in exploratory data analysis.

Later, we will use more specialized graphics packages to create more
sophisticated visualizations.

```{python}
import matplotlib.pyplot as plt

df.high.plot(label='High')
df.low.plot(label='Low')
plt.title('NVIDIA Stock Price')
plt.ylabel('Dollars')
plt.legend(loc='best')
plt.show()
```

---

Or a histogram on the adjusted closing price.

```{python}
df.close.hist()
plt.xlabel('Closing Price')
plt.ylabel('Dollars')
plt.title('NVIDIA Stock Price')
plt.show()
```


## Accessing rows of the DataFrame

So far we've seen how to access a column of the DataFrame. To access a row we use different syntax.

To access a row by its index label, use the **`.loc()`** method ('location').

```{python}
df.loc['01/02/24']
```

As a tangent, we can use the `.apply()` method to format the output.

```{python}
df.loc['01/02/24'].apply(lambda x: '{:,.2f}'.format(x) if isinstance(x, (int, float)) else x)
```

---

To access a row by its index number (i.e., like an array index), use **`.iloc()`** ('integer location')

```{python}
df.iloc[0, :]
```

and similarly formatted:

```{python}
df.iloc[0, :].apply(lambda x: '{:,.2f}'.format(x) if isinstance(x, (int, float)) else x)
```

---

To iterate over the rows you can use **`.iterrows()`**.

```{python}
num_positive_days = 0
for idx, row in df.iterrows():
    if row.close > row.open:
        num_positive_days += 1

print(f"The total number of positive-gain days is {num_positive_days} out of {len(df)} days or as percentage {num_positive_days/len(df):.2%}")
```

::: {.callout-note}
This is only capturing the intraday gain/loss, not the cumulative inter-day gain/loss.
:::

## Filtering

It is easy to select rows from the data.  

All the operations below return a new Series or DataFrame, which itself can be
treated the same way as all Series and DataFrames we have seen so far.

```{python}
tmp_high = df.high > 100
tmp_high.tail()
```

Summing a Boolean array is the same as counting the number of `True` values.

```{python}
sum(tmp_high)
```

---

Now, let's select only the rows of `df` that correspond to `tmp_high`. 

::: {.callout-note}
We can pass a series to the dataframe to select rows.
:::

```{python}
df[tmp_high]
```

---

Putting it all together, we can count the number of positive days without iterating over the rows.

```{python}
positive_days = df[df.close > df.open]
print(f"Total number of positive-gain days is {len(positive_days)}")
positive_days.head()
```

---

Or count the number of days with a gain of more than $2.

```{python}
very_positive_days = df[(df.close - df.open) > 2]
print(f"Total number of days with gain > $2 is {len(very_positive_days)}")
very_positive_days.head()
```

Note that this doesn't the explain the total gain for the year. Why?

## Creating new columns

To create a new column, simply assign values to it. The column name is similar to a key in a dictionary.

Let's look at the daily change in closing price.

```{python}
# Calculate the daily change in closing price
df['daily_change'] = df['close'].diff()

# Create the cumulative profit column
df['cum_profit'] = df['daily_change'].cumsum()

# Display the first few rows to verify the new column
print(df[['close', 'daily_change', 'cum_profit']].head())

```

It is convenient that `.diff()` by default is the difference between the current and previous row.

---

Let's look at the histogram of the daily change in stock price.

```{python}
# Plot histogram of daily_change
plt.figure(figsize=(10, 6))
df['daily_change'].hist(bins=50, edgecolor='black')
plt.title('Histogram of Daily Change in Stock Price')
plt.xlabel('Daily Change')
plt.ylabel('Frequency')
plt.show()

```

---

Let's give each row a `gain` value as a categorical variable.

```{python}
for idx, row in df.iterrows():
    if row.daily_change < 0:
        df.loc[idx,'cat_gain']='negative'
    elif row.daily_change < 1:
        df.loc[idx,'cat_gain']='small_gain'
    elif row.daily_change < 2:
        df.loc[idx,'cat_gain']='medium_gain'
    elif row.daily_change >= 2:
        df.loc[idx,'cat_gain']='large_gain'
df.head()
```

---

Here is another, more "functional", way to accomplish the same thing.

First, let's drop the gain column so we can start fresh.

```{python}
df.drop('cat_gain', axis=1, inplace=True)
df.head()
```

---

Define a function that classifies rows, and `apply` it to each row.

```{python}
def namerow(row):
    if row.daily_change < 0:
        return 'negative'
    elif row.daily_change < 1:
        return 'small_gain'
    elif row.daily_change < 2:
        return 'medium_gain'
    elif row.daily_change >= 2:
        return 'large_gain'

df['cat_gain'] = df.apply(namerow, axis=1)
df.head()
```



# Understanding pandas DataFrame.groupby()

## Introduction

The `groupby()` function is one of the most powerful tools in pandas for data analysis. It implements the "split-apply-combine" pattern:

1. **Split** your data into groups based on some criteria
2. **Apply** a function to each group independently
3. **Combine** the results back into a data structure

Think of it like organizing a deck of cards by suit, then counting how many cards are in each suit, then presenting those counts in a summary table.

## Basic Concept

Imagine you have a dataset of student grades:

```{python}
import pandas as pd

data = {
    'student': ['Alice', 'Bob', 'Alice', 'Bob', 'Charlie', 'Charlie'],
    'subject': ['Math', 'Math', 'English', 'English', 'Math', 'English'],
    'score': [85, 78, 92, 88, 95, 90]
}

df = pd.DataFrame(data)
print(df)
```


## Example 1: Simple Grouping

Let's find the average score for each student:

```{python}
# Group by student and calculate mean
result = df.groupby('student')['score'].mean()
print(result)
```


**What happened?**

- pandas split the data into 3 groups (one per student)
- Applied the `mean()` function to each group's scores
- Combined the results into a Series indexed by the student names

## Example 2: Multiple Aggregations

You can apply multiple functions at once:

```{python}
# Multiple aggregations
result = df.groupby('student')['score'].agg(['mean', 'min', 'max', 'count'])
print(result)
```

where the list in the `agg()` method is both a list of functions to apply to the column and a list of names for the columns in the resulting DataFrame.

**What happened?**

- pandas split the data into 3 groups (one per student)
- Applied the `mean()`, `min()`, `max()`, and `count()` functions to each group's scores
- Combined the results into a DataFrame indexed by the student names with the column names being the functions applied to the scores.

## Example 3: Grouping by Multiple Columns

What if we want to see scores grouped by both student AND subject?

```{python}
# Group by multiple columns
result = df.groupby(['student', 'subject'])['score'].mean()
print(result)
```


This creates a hierarchical index (MultiIndex) with two levels.

## Example 4: Aggregating Multiple Columns

Let's add more data:

```{python}
data = {
    'student': ['Alice', 'Bob', 'Alice', 'Bob', 'Charlie', 'Charlie'],
    'subject': ['Math', 'Math', 'English', 'English', 'Math', 'English'],
    'score': [85, 78, 92, 88, 95, 90],
    'hours_studied': [5, 3, 6, 4, 7, 5]
}

df = pd.DataFrame(data)

# Group by student and get mean of all numeric columns
result = df.groupby('student')[['score', 'hours_studied']].mean()
print(result)
```


## Example 5: Different Aggregations for Different Columns

You can apply different functions to different columns:

```{python}
# Different aggregations for different columns
result = df.groupby('student').agg({
    'score': ['mean', 'max'],
    'hours_studied': 'sum'
})
print(result)
```



## Example 6: Using Custom Functions

You can define your own aggregation functions:

```{python}
# Custom function: range (max - min)
def score_range(x):
    return x.max() - x.min()

result = df.groupby('student')['score'].agg([
    'mean',
    ('range', score_range)
])
print(result)
```

where the argument `('range', score_range)` is a tuple with the name of the column in the resulting DataFrame and the function to apply to the column.

**What happened?**

- pandas split the data into 3 groups (one per student)
- Applied the `mean()` function to the scores column
- Applied the `score_range()` function to the scores column and named the column `range` in the resulting DataFrame
- Combined the results into a DataFrame indexed by the student names with the column names being the functions applied to the scores.


## Example 7: Filtering Groups

You can filter out entire groups based on conditions:

```{python}
# Only keep students with average score above 85
result = df.groupby('student').filter(lambda x: x['score'].mean() > 85)
print(result)
```



## Example 8: Transform - Keeping Original Shape

Sometimes you want to add group statistics to your original dataframe:

```{python}
# Add a column with each student's average score
df['student_avg'] = df.groupby('student')['score'].transform('mean')
print(df)
```


Notice how `transform()` returns a Series with the same length as the original DataFrame, broadcasting the group statistic to all rows in that group.

## Example 9: Apply - Maximum Flexibility

The `apply()` method gives you complete control and can return different shapes:

```{python}
# Use apply() to get multiple statistics per group
def analyze_student(group):
    return pd.Series({
        'avg_score': group['score'].mean(),
        'score_range': group['score'].max() - group['score'].min(),
        'total_hours': group['hours_studied'].sum(),
        'efficiency': group['score'].mean() / group['hours_studied'].mean()
    })

result = df.groupby('student').apply(analyze_student, include_groups=False)
print(result)
```


Note: Unlike `transform()` which must return the same shape as the input, `apply()` can return aggregated results of any shape.


## Example 10: Iterating Over Groups

Sometimes you need to process each group separately:

```{python}
# Iterate over groups
for name, group in df.groupby('student'):
    print(f"\n{name}'s records:")
    print(group)
```



## Common Aggregation Functions

Here are the most commonly used aggregation functions:

- `count()` - Number of non-null values
- `sum()` - Sum of values
- `mean()` - Average of values
- `median()` - Median value
- `min()` - Minimum value
- `max()` - Maximum value
- `std()` - Standard deviation
- `var()` - Variance
- `first()` - First value in group
- `last()` - Last value in group
- `size()` - Number of rows (including NaN)

## Example 11: (Synthetic) Sales Data Analysis

```{python}
# Sample sales data
sales_data = {
    'date': pd.date_range('2024-01-01', periods=12, freq='ME'),
    'region': ['North', 'South', 'North', 'South', 'North', 'South',
               'North', 'South', 'North', 'South', 'North', 'South'],
    'product': ['A', 'A', 'B', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B'],
    'sales': [100, 150, 200, 175, 110, 165, 210, 180, 120, 170, 220, 190],
    'units': [10, 15, 20, 17, 11, 16, 21, 18, 12, 17, 22, 19]
}

sales_df = pd.DataFrame(sales_data)
print(sales_df)

# Comprehensive analysis by region
analysis = sales_df.groupby('region').agg({
    'sales': ['sum', 'mean', 'max'],
    'units': 'sum',
    'product': 'count'  # Count of transactions
})

print("\nAnalysis:")
print(analysis)
```


## Tips and Best Practices

1. **Reset Index**: After groupby operations, you often want to reset the index:
   ```{python}
   result = df.groupby('student')['score'].mean().reset_index()
   print("\nResult:")
   print(result)
   
   result2 = df.groupby('student')['score'].mean().reset_index()
   print("\nResult2:")
   print(result2)
   ```

2. **Naming Aggregations**: Give your aggregated columns meaningful names:
   ```{python}
   result = df.groupby('student').agg(
       avg_score=('score', 'mean'),
       total_hours=('hours_studied', 'sum')
   )
   ```

3. **Performance**: For large datasets, groupby is highly optimized in pandas. It's usually faster than writing loops.

4. **Missing Values**: By default, groupby excludes NaN values from groups. Use `dropna=False` to include them:
   ```{python}
   df.groupby('student', dropna=False)['score'].mean()
   ```

5. **Sort Results**: Control sorting with `sort=True/False`:
   ```{python}
   df.groupby('student', sort=False)['score'].mean()  # Preserve original order
   ```

## Visualizing Grouped Data

Groupby works seamlessly with pandas plotting:

```{python}
# Create a bar chart of average scores by student
df.groupby('student')['score'].mean().plot(kind='bar')
```

## `groupby()` Summary

The `groupby()` function is essential for:

- Calculating statistics by category
- Finding patterns in subgroups
- Data aggregation and summarization
- Feature engineering (with transform)
- Comparative analysis

Master the split-apply-combine pattern, and you'll unlock powerful data analysis capabilities!

## `groupby()` Practice Exercise

Try this on your own:

```{python}
# Create sample data
practice_data = {
    'department': ['Sales', 'Sales', 'IT', 'IT', 'HR', 'HR', 'Sales', 'IT'],
    'employee': ['John', 'Jane', 'Bob', 'Alice', 'Tom', 'Mary', 'Steve', 'Linda'],
    'salary': [50000, 55000, 65000, 70000, 48000, 52000, 53000, 68000],
    'experience': [2, 3, 5, 7, 1, 4, 3, 6]
}

practice_df = pd.DataFrame(practice_data)

# Try to answer:
# 1. What's the average salary by department?
# 2. What's the total experience and max salary by department?
# 3. Add a column showing each employee's salary as a percentage of their department's total?
```



# Other Pandas Classes

A DataFrame is essentially an annotated 2-D array.

Pandas also has annotated versions of 1-D and 3-D arrays.

A 1-D array in Pandas is called a [Series](https://pandas.pydata.org/docs/reference/series.html). 
You can think of DataFrames as a dictionary of Series.

A 3-D array in Pandas is created using a
[MultiIndex](https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html#).

For more information read the documentation.


# In Class Activity

### Iris Flower Analysis with Pandas
**Duration:** 20-25 minutes | **Teams:** 3 students each

#### Dataset: Iris Flower Dataset
**Download Instructions:**
The Iris dataset is built into seaborn, so no download needed!

```{python}
import pandas as pd
import seaborn as sns

# Load the Iris dataset directly
iris = sns.load_dataset('iris')
```


#### Team Roles (2 minutes)
- **Data Loader:** Loads data and explores structure
- **Data Analyzer:** Performs calculations and filtering  
- **Data Visualizer:** Creates plots and charts

#### Activity Tasks (20 minutes)

**Phase 1: Data Loading & Exploration (5 minutes)**
1. Check the shape and column names
2. Use `.head()`, `.info()`, and `.describe()` to explore the data

```python

# Replace 0 and '[]' with the correct methods on iris
print(f"Dataset shape: {0}")
print(f"Columns: {['']}")

# Look at the first few rows
print("First 5 rows:")

# Get basic info about the dataset
print("\nDataset Info:")

# Describe the dataset with summary statistics
print("\nSummary Statistics:")

```

**Phase 2: Basic Data Manipulation (8 minutes)**
1. **Create new columns:**
   - Add a 'petal_area' column (petal_length × petal_width)
   - Create a 'sepal_area' column (sepal_length × sepal_width)
   - Create a 'size_category' column:
     - 'Small' (petal_area < 2)
     - 'Medium' (petal_area 2-5) 
     - 'Large' (petal_area > 5)

```python
# Create petal area column
iris['petal_area'] = ...

# Create sepal area column
iris['sepal_area'] = ...

# Create size category column
def categorize_size(petal_area):
    if ... :
        return 'Small'
    elif ... :
        return 'Medium'
    else:
        return 'Large'

iris['size_category'] = ...

print("New columns created:")
print(iris[['petal_length', 'petal_width', 'petal_area', 'size_category']].head(10))
```

2. **Data Filtering:**
   - Find all 'setosa' species flowers
   - Filter for large flowers only
   - Find flowers with sepal_length > 6

```python
# Find all 'setosa' species flowers
setosa_flowers = ...
print(f"Setosa flowers: {len(setosa_flowers)} out of {len(iris)}")

# Filter for large flowers only
large_flowers = ...
print(f"Large flowers: {len(large_flowers)} out of {len(iris)}")

# Find flowers with sepal_length > 6
long_sepal = ...
print(f"Flowers with sepal_length > 6: {len(long_sepal)} out of {len(iris)}")
```

3. **Basic Analysis:**
   - Count flowers by species
   - Find average petal length by species

```python
# Count flowers by species
species_counts = ...
print("Flowers by species:")
print(species_counts)

# Find average petal length by species
avg_petal_by_species = ...
print("\nAverage petal length by species:")
print(avg_petal_by_species)
```

**Phase 3: Simple Visualizations (7 minutes)**
1. **Create 2-3 basic plots:**
   - Histogram of petal length
   - Bar chart of flower count by species
   - Scatter plot: sepal_length vs sepal_width

```python
# Create a figure with subplots
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# 1. Histogram of petal length
axes[0, 0].hist(iris['petal_length'], bins=15, alpha=0.7, edgecolor='black', color='skyblue')
axes[0, 0].set_title('Distribution of Petal Length')
axes[0, 0].set_xlabel('Petal Length (cm)')
axes[0, 0].set_ylabel('Frequency')
axes[0, 0].grid(True, alpha=0.3)

# 2. Bar chart of flower count by species
species_counts = iris['species'].value_counts()
species_counts.plot(kind='bar', ax=axes[0, 1], color=['red', 'green', 'blue'])
axes[0, 1].set_title('Number of Flowers by Species')
axes[0, 1].set_xlabel('Species')
axes[0, 1].set_ylabel('Number of Flowers')
axes[0, 1].tick_params(axis='x', rotation=45)
axes[0, 1].grid(True, alpha=0.3)

# 3. Scatter plot: sepal_length vs sepal_width
for species in iris['species'].unique():
    data = iris[iris['species'] == species]
    axes[1, 0].scatter(data['sepal_length'], data['sepal_width'], 
                      alpha=0.7, label=species, s=50)
axes[1, 0].set_title('Sepal Length vs Sepal Width (by Species)')
axes[1, 0].set_xlabel('Sepal Length (cm)')
axes[1, 0].set_ylabel('Sepal Width (cm)')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

# 4. Bar chart of size categories (if size_category column exists)
if 'size_category' in iris.columns:
    size_categories = iris['size_category'].value_counts()
    size_categories.plot(kind='bar', ax=axes[1, 1], color=['orange', 'lightgreen', 'lightcoral'])
    axes[1, 1].set_title('Flowers by Size Category')
    axes[1, 1].set_xlabel('Size Category')
    axes[1, 1].set_ylabel('Number of Flowers')
    axes[1, 1].tick_params(axis='x', rotation=0)
    axes[1, 1].grid(True, alpha=0.3)
else:
    # Alternative: petal length vs petal width scatter
    axes[1, 1].scatter(iris['petal_length'], iris['petal_width'], alpha=0.7, s=50)
    axes[1, 1].set_title('Petal Length vs Petal Width')
    axes[1, 1].set_xlabel('Petal Length (cm)')
    axes[1, 1].set_ylabel('Petal Width (cm)')
    axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

**Upon Completion:**

Execute all the cells, save and download the notebook and submit to Gradescope.

# Recap

In this section we got a first glimpse of the Pandas library.

We learned how to:

* load data from a CSV file
* inspect the data
* manipulate the data
* plot the data
* access rows and columns of the dataframe
* filter the data
* create new columns
* group the data

