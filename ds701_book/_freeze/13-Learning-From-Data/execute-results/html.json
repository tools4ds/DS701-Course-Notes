{
  "hash": "a30ec68423efb8bfc98ea9cc2d47f468",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Learning From Data\njupyter: python3\n---\n\n## Introduction\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/13-Learning-From-Data.ipynb)\n\n\n\nThe idea of learning from data is one of the most important shifts in thinking\nabout computing to come about in the past 50 years.\n\nNot that long ago, it was commonly thought that:\n\n>\"Computers can only do what we tell them to do.\"\n\nor\n\n>\"Computers can not create anything new.  They can only do what we already know how to do.\"\n\n---\n\n<!-- SSPL/Getty -->\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n\n![](figs/ada_lovelace.jpeg){height=500px}\n\n:::\n::: {.column width=\"60%\"}\n\nThis line of argument goes back to Lady Ada Lovelace, often credited as the first programmer.\n\nWorking with Charles Babbage, she wrote about the Analytical Engine:\n\n>The Analytical Engine has no pretensions whatever to originate anything. It can do whatever we know how to order it to perform. It can follow analysis; but it has no power of anticipating any analytical relations or truths.\n\nAda Augusta Lovelace, Commentary on \"Sketch of the Analytical Engine\" (1843)\n\n:::\n::::\n\n\n## Can Computers Create Something New?\n\nGenerative Techniques:\n\n1. ChatGPT\n2. Generative Image AI\n3. Generative Music AI\n4. Claude/Cursor/Copilot Code\n\nIs this innovation? Invention? Recombination?\n\n\n## Paradigm Shift\n\nLearning from data is a paradigm shift of _some kind_.\n\n* It is no longer purely prescriptive\n* We can build models at a scale that can solve problems humans cannot\n\n\n* Computers routinely beat the world's experts in games of chess, go, etc.\n\nIn each case, the programmers who wrote the programs may not themselves know how to perform these tasks well.\n\nInstead, those programmers have written programs that __learn from data.__\n\nSo we will spend some time now talking about the general problem of learning from data.\n\n## The Supervised Learning Problem\n\nThe supervised learning problem in general is:\n    \n* You are given some example data, which we'll think of abstractly as tuples $\\{(\\mathbf{x}_i, y_i)\\,|\\,i = 1,\\dots,N\\}$.  \n    * $\\mathbf{x}_i$ are the inputs or independent variables.\n    * $y_i$ are the outputs or dependent variables, (a.k.a. labels, targets or ground truth)\n\n* Your goal is to learn a rule that allows you to predict $y_j$ for some $\\mathbf{x}_j$ that is not in the example data you were given.\n\n\n* Typically $\\mathbf{x}$ is a vector. Sometimes $y_i$ is too.\n\n* We use the term \"features\" to refer to the components of $\\mathbf{x}$.\n\n* The collection $\\{(\\mathbf{x}_i, y_i)\\,|\\,i = 1,\\dots,N\\}$ is called the __training data.__\n\n* The collection $\\{(\\mathbf{x}_j, y_j)\\,|\\,j = 1,\\dots,M\\}$ is called the __test data.__\n\n## Classification versus Regression\n\n* If $y$ is a discrete value (a label, for example) then the problem is called __classification.__\n\n* For example, in image recognition, the features $\\mathbf{x}$ could be a vector that represents the pixels of the image, and $y$ could be a label such as \"tiger,\" \"tree,\" etc.\n\n* If $y$ is a continuous (numeric) value, then the problem is called __regression.__ \n\n* For example, in predicting housing prices, the features $\\mathbf{x}$ could be a vector containing lot size, square footage, number of bathrooms, etc., and $y$ could be the sale price of the house.\n\n* In the regression case, you will usually be satisfied if your prediction is __close__ to the true $y$ (it doesn't have to be exact to be useful).\n\n## Assumptions\n\nWhat do we have to assume to make this problem tractable?\n\nWe assume two things:\n\n1. There is a set of functions that could be used to predict $y_i$ from $\\mathbf{x}_i$.\n    * This allows us to turn the learning problem into one that searches through this set for the \"right\" function.   \n    * However, this set is probably __very__ large!\n\n2. The rule for predicting $y_i$ from $\\mathbf{x}_i$ is the same as the rule for predicting $y_j$ from the new item $\\mathbf{x}_j$. \n    * Speaking probabilistically, we say that $(\\mathbf{x}_i, y_i)$ and $(\\mathbf{x}_j, y_j)$ are drawn from the __same distribution.__\n\n## A Toy Example\n\n::: {.callout-note}\nThe following is based on _Pattern Recognition and Machine Learning,_ Christopher Bishop (2006), Section 1.1.\n:::\n\nIn order to explore these ideas a bit, we'll use a toy example: a regression problem.\n\nThis is a very artificial example, but it will expose some important wrinkles in the supervised learning problem.\n\nWe will consider polynomial curve fitting.\n\n## Polynomial Curve Fitting\n\nSuppose we are given a training set comprising $N$ observations of a scalar value $x_i$, which we'll collect into the vector $\\mathbf{x}$.  \n\nFor each $x_i$ we have a corresponding numeric value $y_i$, and these form $\\mathbf{y}$.\n\nHere is a plot of the 10 training points:\n\n::: {#fad4f1d6 .cell execution_count=2}\n``` {.python .cell-code}\nN = 10\nx = np.linspace(0, 1, N)\nfrom numpy.random import default_rng\ny = np.sin(2 * np.pi * x) + default_rng(2).normal(size = N, scale = 0.20)\nplt.figure(figsize = (5, 3))\nplt.plot(x, y, 'ro', markersize = 8, fillstyle = 'none')\nplt.xlabel('x', size = 16)\nplt.ylabel('y', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-3-output-1.png){width=459 height=290 fig-align='center'}\n:::\n:::\n\n\n## The Underlying Sine Curve\n\n::: {#97d9ff51 .cell execution_count=3}\n``` {.python .cell-code}\ncx = np.linspace(0, 1, 1000)\ncy = np.sin(2 * np.pi * cx)\nplt.figure(figsize = (5, 3))\nplt.plot(cx, cy, lw = 2)\nplt.plot(x, y, 'ro', markersize = 8, fillstyle = 'none')\nplt.xlabel('x', size = 16)\nplt.ylabel('y', size = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-4-output-1.png){width=459 height=290 fig-align='center'}\n:::\n:::\n\n\nThe way we generated these points was to take $\\mathbf{x}$ as equal spaced points in the range 0 to 1,\nand for each $x_i$, we take $y_i = \\sin(2\\pi x_i)$ __plus__ a sample of a Gaussian random variable.\n\nMany data sets are like this!  \n\n## The Noise\n\n* In many cases, there is some component of $y$ that depends on $x$, and some component that we treat as random, called \"noise.\"\n\n* The \"noise\" component might not __really__ be random, but rather depends on features that we cannot see.\n\n* Remember, probability is useful for exactly this case.)\n\n* Now for this toy example, we \"happen\" to know that the __correct__ rule to use for prediction is:\n    \n$$\ny = \\sin(2\\pi x) \n$$\n\n* and the Gaussian random addition does not depend on $x$ so we cannot hope to predict it.\n\n## Model Fitting\n\n* We will consider a simple approach based on curve fitting.\n\n* The class of models we will consider are polynomials.   \n\nThey are of the form:\n\n$$\nf(x, \\mathbf{w}) = w_0 + w_1 x + w_2 x^2 + \\dots + w_k x^k = \\sum_{j = 0}^k w_jx^j \n$$\n\nwhere $k$ is the _order_ of the polynomial.\n\nIf we are given some $k$, then what we want to learn are the $w_i$s, that is, $\\mathbf{w}$.  \n\n## The Polynomial Model\n\n$$\nf(x, \\mathbf{w}) = w_0 + w_1 x + w_2 x^2 + \\dots + w_k x^k = \\sum_{j = 0}^k w_jx^j \n$$\n\n\nThe $w_i$s are the __parameters__ of the model.\n\n* Note that this function $y(x, \\mathbf{w})$ is a nonlinear function in $x$ ... but it is __linear__ in $\\mathbf{w}$.  That is, all the $w_i$s appear only raised to the first power.   \n\n* This model is linear in its parameters -- it is called a __linear model.__\n\n* Linear models are particularly easy to fit to data.\n\n## Least Squares Criterion\n\n* How will we fit our model, that is, learn the best parameters $\\mathbf{w}$?\n\n* We will use an objective function to guide our search through the space of model parameters.\n\n* The objective function we will use is called the __least squares criterion__:\n\n$$\nE(\\mathbf{w}) = \\sum_{n=1}^N [f(x_n, \\mathbf{w}) - y_n]^2 \n$$\n\nThis is a nonnegative function which is zero if the polynomial passes through every point exactly.\n\n## Least Squares Criterion, cont.\n\nWe often write $\\hat{y}_n$ for $f(x_n, \\mathbf{w})$.\n\nThen:\n\n$$\nE(\\mathbf{w}) = \\Vert \\hat{\\mathbf{y}} - \\mathbf{y} \\Vert^2. \n$$\n\n* In other words, the error function $E(\\cdot)$ measures the distance or dissimilarity between the data and the predictions.\n\n* Finding a $\\mathbf{w}$ that minimizes $E(\\mathbf{w})$ is a least-squares problem, and we can solve it in closed form (details later in the course).\n\n* The resulting solution $\\mathbf{w}^*$ is the set of parameters that __minimizes the error on the training data.__\n\n## Model Selection\n\nSo we are done, correct?\n\n* Wait ... what about choosing $k$, the order of the polynomial?\n\n* The problem of choosing $k$ is called __model selection.__\n\n* That is, a polynomial of order 3 (a cubic) is a __different model__ from a polynomial of order 2 (a quadratic).\n\n## Model Selection, cont.\n\nLet's look at constant (order 0), linear (order 1), and cubic (order 3) models.\n\nWe will fit each one using the least squares criterion:\n\n\n\n::: {#9e914964 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-6-output-1.png){width=938 height=324}\n:::\n:::\n\n\nSo it looks like a third-order polynomial ($k$ = 3) is a good fit!\n\nHow do we know it's good?   Well, the training error $E(\\mathbf{w})$ is small.\n\n## Make training error smaller?\n\nYes, we can, if we increase the order of the polynomial.\n\nWe can reduce the error to zero by setting $k = 9$, we get the following polynomial fit to the data:\n\n::: {#166a2f84 .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-7-output-1.png){width=459 height=328 fig-align='center'}\n:::\n:::\n\n\nSo ... is the 9th order polynomial a \"better\" model for this dataset?\n\n## Absolutely not!\n\n**Why?**\n\n* Informally, the model is very \"wiggly\".  It seems unlikely that the real data generation process is governed by this curve.\n\n* In other words, we don't expect that, if we had __more__ data from the same source, that this model would do a good job of fitting the additional data.\n\n* We want the model to do a good job of predicting on __future__ data.  \n\n* This is called the model's __generalization__ ability.   \n\nThe 9th degree polynomial would seem to have poor generalization ability.\n\n## Generalization Error\n\n* Let's assess generalization error.   \n\n* For each polynomial (value of $k$) we will use new data, called __test__ data -- not part of the training set.\n\n* In our case, we know how the data is generated -- $\\sin(2\\pi x)$ plus noise -- so we can easily generate more.\n\n\n## Generalization Error, cont.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* Notice that as we increase the order of the polynomial, the _training error_ always declines.\n\n* Eventually, the training error reaches zero.\n\n* However, the _test error_ does not -- it reaches its smallest value at $k = 3$, a cubic polynomial.\n\n* The phenomenon in which _training error_ declines, but _testing error_ does not, is called __overfitting.__\n\n* In a sense we are fitting the training data \"too well\".\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#32b0f467 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-8-output-1.png){width=526 height=367 fig-align='center'}\n:::\n:::\n\n\n:::\n\n::::\n\n## Overfitting\n\nThere are two ways to think about overfitting:\n\n1. The number of parameters in the model is too large, compared to the size of the training data.   We can see this in the fact that we have only 10 training points, and the 9th order polynomial has 10 coefficents. \n\n2. The model is more complex than the actual phenomenon being modeled.  As a result, the model is not just fitting the underlying phenomenon, but also the noise in the data.\n\nThese suggest techniques we may use to avoid overfitting:\n\n1. Increase the amount of training data.  All else being equal, more training data is always better.\n\n2. Limit the complexity of the model.  Model complexity is often controlled via __hyperparameters__.\n\n3. Use regularization -- constrain the model to avoid overfitting.\n\n## More Training Data\n\nIt's not necessarily true that a order-3 polynomial is best for this problem.\n\nBut the higher the order of polynomial we want to fit, the more data we need to avoid overfitting.\n\nHere we use an order-9 polynomial for increasing amounts of training data (N = 15, 50, 200):\n\n\n\n::: {#9328f72e .cell execution_count=9}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-10-output-1.png){width=946 height=278}\n:::\n:::\n\n\nWe see that with enough training data, the high order polynomial begins to capture the sine wave well.\n\n## Parameters and Hyperparameters\n\n* Many times however, we cannot simply get more training data, or enough training data, to solve the overfitting problem. \n\n* In that case, we need to control the complexity of the model.\n\n* Notice that model selection problem required us to choose a value $k$ that specifies the order of the polynomial model.\n\n* As already mentioned, the values $w_0, w_1, \\dots, w_k$ are called the __parameters__ of the model.\n\n* In contrast, $k$ is called a __hyperparameter.__\n\n## Parameters and Hyperparameters, cont.\n\n* A hyperparameter is a parameter that must be set first, before the (regular) parameters can be learned.\n\n* Hyperparameters are often used to control model complexity.\n\n* Here, the hyperparameter $k$ controls the complexity (the order) of the polynomial model.\n\n* So, to avoid overfitting, we need to choose the proper value for the hyperparameter $k$.\n\n* We do that by __holding out data.__\n\n## Holding Out Data\n\n* The idea behind holding out data is simple.\n\n* We want to avoid overfitting, which occurs when a model fails to generalize -- that is, when it has high error on  data that it was not trained on.\n\n* So: we will hold some data aside, and __not__ use it for training the model, but instead use it for testing generalization ability.\n\n* Let's assume that we have 20 data points to work with, stored in arrays `x` and `y`.\n\n* `scikit-learn` has some functions that can be helpful. \n\n## Train-Test Splitting\n\nWe will use `train_test_split()`:\n\n::: {#ae677992 .cell execution_count=10}\n``` {.python .cell-code code-fold=\"false\"}\nN = 20\nx = np.linspace(0, 1, N)\ny = np.sin(2 * np.pi * x) + default_rng(2).normal(size = N, scale = 0.20)\n\nimport sklearn.model_selection as model_selection\n\nx_train, x_test, y_train, y_test = model_selection.train_test_split(\n        x, y, test_size = 0.5, random_state = 0)\n\nprint(f'Number of items in training set: {x_train.shape[0]}, in testing set: {x_test.shape[0]}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of items in training set: 10, in testing set: 10\n```\n:::\n:::\n\n\nNotice that `train_test_split()` splits the data __randomly.__\n\nThis will be important.\n\n## Train-Test Splitting, cont.\n\n::: {#7bf5f1ab .cell execution_count=11}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-12-output-1.png){width=553 height=232 fig-align='center'}\n:::\n:::\n\n\nOur strategy will be:\n\n* For each possible value of the hyperparameter $k$:\n    * randomly split the data 5 times\n    * compute the mean testing and training error over the 5 random splits\n\nWhat are good possible values for the hyperparameter?  It can depend on the problem, and may involve trial and error.\n\n## Grid Search\n\nThis strategy of trying all possible values of the hyperparameter is called a __grid search__.\n\n\n\n::: {#9bc94b8f .cell execution_count=13}\n\n::: {.cell-output .cell-output-display execution_count=218}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>k</th>\n      <th>split</th>\n      <th>Training Error</th>\n      <th>Testing Error</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0</td>\n      <td>1.147829</td>\n      <td>2.799292</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>1</td>\n      <td>1.700576</td>\n      <td>1.712716</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2</td>\n      <td>1.387723</td>\n      <td>2.133381</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>3</td>\n      <td>1.696808</td>\n      <td>1.695534</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>4</td>\n      <td>1.571746</td>\n      <td>1.989020</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>0</td>\n      <td>1.358846</td>\n      <td>2.603490</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>1</td>\n      <td>1.332199</td>\n      <td>2.082828</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2</td>\n      <td>0.747769</td>\n      <td>5.436927</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>3</td>\n      <td>1.559011</td>\n      <td>2.697498</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>4</td>\n      <td>1.677090</td>\n      <td>1.691438</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Grid Search, cont.\n\nLet's plot the mean for each value of `k` and its standard error ($\\sigma/\\sqrt{n}$):\n\n::: {#f99af309 .cell execution_count=14}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-15-output-1.png){width=502 height=361 fig-align='center'}\n:::\n:::\n\n\nFrom this plot we can conclude that, for this dataset, a polynomial of degree $k = 3$ shows the best generalization ability.\n\n## Hold Out Strategies\n\n* Deciding how much, and which, data to hold out depends on a number of factors.\n\n* In general we'd like to give the training stage as much data as possible to work with.\n\n* However, the more data we use for training, the less we have for testing -- which can decrease the accuracy of the testing stage.\n\n* Furthermore, any single partition of the data can introduce dependencies -- any class that is overrepresented in the training data will be underrepresented in the test data.\n\nThere are two ways to address these problems:\n\n* Random subsampling\n* Cross-validation\n\n## Random Subsampling\n\n* In __random subsampling__ one partitions the data randomly between train and test sets.  This is what the function `train_test_split()` does.\n\n* This ensures there is no dependence between the test and train sets.\n\n* One needs to perform a reasonable number of random splits - usually five at least.\n\n## Cross-Validation\n\nIn __cross-validation__, the data is partitioned once, and then each partition is used as the test data once.\n\nThis ensures that all the data gets equal weight in the training and in the testing.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* We divide the data into $k$ \"folds\".\n\n* The value of $k$ can vary up to the size of the dataset.\n\n* The larger $k$ we use, the more data is used for training, but the more folds must be evaluated, which increases the time required.\n\n* In the extreme case where $k$ is equal to the data size, then each data item is held out by itself; this is called \"leave-one-out\".\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](figs/L13-k-fold.png){fig-align=\"center\"}\n\n:::\n\n::::\n\n## Conclusions\n\nWe have seen strategies that allow us to learn from data.\n\nThe strategies include:\n\n* Define a set of possible models\n* Define an error function that tells us when the model is predicting well\n* Using the error function, search through the space of models to find the best performer\n\nWe've also seen that there are some subtleties to this approach that must be dealt with to avoid problems:\n\n* Simply using the model that has lowest error on the training data will __overfit__.\n* We need to __hold out__ data to assess the generalization ability of each trained model.\n* We control model complexity using hyperparameters.\n* We choose the best hyperparameters based on performance on held out data.\n\n",
    "supporting": [
      "13-Learning-From-Data_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}