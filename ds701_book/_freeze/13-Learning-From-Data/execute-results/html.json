{
  "hash": "e754302b705f23954c5a085c3ee05617",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Learning From Data\njupyter: python3\n---\n\n## Introduction\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/13-Learning-From-Data.ipynb)\n\n\n\nWe are now beginnging to discuss how to learn from data.\n\nThe idea of learning from data is one of the most important shifts in thinking\nabout computing to come about in the past 50 years.\n\nConsider the commonly heard phrase:\n\n>\"Computers can only do what we tell them to do.\"\n\nor\n\n>\"Computers can not create anything new.  They can only do what we already know how to do.\"\n\n---\n\n<!-- SSPL/Getty -->\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n\n![](figs/ada_lovelace.jpeg){height=500px}\n\n:::\n::: {.column width=\"60%\"}\n\nThis line of argument goes back to Lady Ada Lovelace, often credited as the first programmer.\n\nWorking with Charles Babbage, she wrote about the Analytical Engine:\n\n>The Analytical Engine has no pretensions whatever to originate anything. It can do whatever we know how to order it to perform. It can follow analysis; but it has no power of anticipating any analytical relations or truths.\n\nAda Augusta Lovelace, Commentary on \"Sketch of the Analytical Engine\" (1843)\n\n:::\n::::\n\n---\n\nHowever, it is clear that this viewpoint is entirely __wrong.__\n\nAll around us today, computers solve problems that humans do not know how to solve.\n\nComputers routinely beat the world's experts in games of chess, go, etc.    They perform tasks such as facial recognition, speech synthesis, automatic language translation, and so forth.   \n\nIn each case, the programmers who wrote the programs may not themselves know how to perform these tasks.\n\nInstead, those programmers have written programs that __learn from data.__\n\nHowever, the best methods for learning from data have taken decades to develop.  \n\nSo we will spend some time now talking about the general problem of learning from data.\n\n## The Supervised Learning Problem\n\nThe supervised learning problem in general is:\n    \nYou are given some example data, which we'll think of abstractly as tuples $\\{(\\mathbf{x}_i, y_i)\\,|\\,i = 1,\\dots,N\\}$.  \n\nYour goal is to learn a rule that allows you to predict $y_j$ for some $\\mathbf{x}_j$ that is not in the example data you were given.\n\nTypically $\\mathbf{x}$ is a vector.\n\nWe use the term \"features\" to refer to the components of $\\mathbf{x}$.\n\nThe collection $\\{(\\mathbf{x}_i, y_i)\\,|\\,i = 1,\\dots,N\\}$ is called the __training data.__\n\n---\n\nIf $y$ is a discrete value (a label, for example) then the problem is called __classification.__\n\nFor example, in image recognition, the features $\\mathbf{x}$ could be a vector that represents the pixels of the image, and $y$ could be a label such as \"tiger,\" \"tree,\" etc.\n\nIf $y$ is a continuous (numeric) value, then the problem is called __regression.__ \n\nFor example, in predicting housing prices, the features $\\mathbf{x}$ could be a vector containing lot size, square footage, number of bathrooms, etc., and $y$ could be the sale price of the house.\n\nIn the regression case, you will usually be satisfied if your prediction is __close__ to the true $y$ (it doesn't have to be exact to be useful).\n\n---\n\nWhat do we have to assume to make this problem tractable?\n\nWe assume two things:\n\n1. There is a set of functions (\"rules\") that could be used to predict $y_i$ from $\\mathbf{x}_i$.   This allows us to turn the learning problem into one that searches through this set for the \"right\" function.   However, this set is probably __very__ large!\n\n2. The rule for predicting $y_i$ from $\\mathbf{x}_i$ is the same as the rule for predicting $y_j$ from the new item $\\mathbf{x}_j$. Speaking probabilistically, we say that $(\\mathbf{x}_i, y_i)$ and $(\\mathbf{x}_j, y_j)$ are drawn from the __same distribution.__\n\n## A Toy Example\n\n::: {.callout-note}\nThe following is based on _Pattern Recognition and Machine Learning,_ Christopher Bishop (2006), Section 1.1.\n:::\n\nIn order to explore these ideas a bit, we'll use a toy example: a regression problem.\n\nThis is a very artificial example, but it will expose some important wrinkles in the supervised learning problem.\n\nWe will consider polynomial curve fitting.\n\n## Polynomial Curve Fitting\n\nSuppose we are given a training set comprising $N$ observations of a scalar value $x_i$, which we'll collect into the vector $\\mathbf{x}$.  \n\nFor each $x_i$ we have a corresponding numeric value $y_i$, and these form $\\mathbf{y}$.\n\nHere is a plot of the 10 training points:\n\n::: {layout-ncol=2}\n\n::: {#a55a9795 .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![The training data.](13-Learning-From-Data_files/figure-html/cell-3-output-1.png){width=459 height=290}\n:::\n:::\n\n\n::: {#619b2e4d .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![The underlying sine curve.](13-Learning-From-Data_files/figure-html/cell-4-output-1.png){width=459 height=290}\n:::\n:::\n\n\n:::\n\nThe way we generated these points was to take $\\mathbf{x}$ as equal spaced points in the range 0 to 1,\nand for each $x_i$, we take $y_i = \\sin(2\\pi x_i)$ __plus__ a sample of a Gaussian random variable.\n\nMany data sets are like this!  \n\n---\n\nIn many cases, there is some component of $y$ that depends on $x$, and some component that we treat as random, called \"noise.\"\n\nThe \"noise\" component is typically not __really__ random, but rather depends on features that we cannot see.\n\n(Remember, probability is useful for exactly this case.)\n\nNow for this toy example, we \"happen\" to know that the __correct__ rule to use for prediction is:\n    \n$$ y = \\sin(2\\pi x) $$\n\nand the Gaussian random addition does not depend on $x$ so we cannot hope to predict it.\n\n---\n\nOK, let's learn from this data.\n\nWe will consider a simple approach based on curve fitting.\n\nThe class of models we will consider are polynomials.   They are of the form:\n\n$$\ny(x, \\mathbf{w}) = w_0 + w_1 x + w_2 x^2 + \\dots + w_k x^k = \\sum_{j = 0}^k w_jx^j \n$$\n\nwhere $k$ is the _order_ of the polynomial.\n\nIf we are given some $k$, then what we want to learn are the $w_i$s, that is, $\\mathbf{w}$.  \n\nThe $w_i$s are the __parameters__ of the model.\n\nNote that this function $y(x, \\mathbf{w})$ is a nonlinear function in $x$ ... but it is __linear__ in $\\mathbf{w}$.  That is, all the $w_i$s appear only raised to the first power.   \n\nThis model is linear in its parameters -- it is called a __linear model.__\n\nLinear models are particularly easy to fit to data.\n\n## Model Fitting\n\nHow will we fit our model, that is, learn the best parameters $\\mathbf{w}$?\n\nWe will use an objective function to guide our search through the space of model parameters.\n\nThe objective function we will use is called the __least squares criterion__:\n\n$$\nE(\\mathbf{w}) = \\sum_{n=1}^N [y(x_n, \\mathbf{w}) - y_n]^2 \n$$\n\nThis is a nonnegative function which is zero if the polynomial passes through every point exactly.\n\n---\n\nWe often write $\\hat{y}_n$ for $y(x_n, \\mathbf{w})$.\n\nThen:\n\n$$\nE(\\mathbf{w}) = \\Vert \\hat{\\mathbf{y}} - \\mathbf{y} \\Vert^2. \n$$\n\nIn other words, the error function $E(\\cdot)$ measures the distance or dissimilarity between the data and the predictions.\n\nFinding a $\\mathbf{w}$ that minimizes $E(\\mathbf{w})$ is a least-squares problem, and we can solve it in closed form (details later in the course).\n\nThe resulting solution $\\mathbf{w}^*$ is the set of parameters that __minimizes the error on the training data.__\n\n## Model Selection\n\nSo we are done, correct?\n\nWait ... what about choosing $k$, the order of the polynomial?\n\nThe problem of choosing $k$ is called __model selection.__\n\nThat is, a polynomial of order 3 (a cubic) is a __different model__ from a polynomial of order 2 (a quadratic).\n\nLet's look at constant (order 0), linear (order 1), and cubic (order 3) models.\n\nWe will fit each one using the least squares criterion:\n\n::: {#546cdd9b .cell execution_count=4}\n``` {.python .cell-code}\n# y = Aw, A is design matrix 1, [1, x^T], [1, x^T, x^T^2], etc, and w-hat = (A^TA)^-1 A^Ty\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef design_matrix(x, k):\n    N = len(x)\n    A = np.ones(N)\n    for i in range(1, k+1):\n        A = np.column_stack([A, (x.T)**i])\n    return A\n\ndef fit_poly(x, y, k):\n    A = design_matrix(x, k)\n    w_hat = np.linalg.inv(A.T @ A) @ A.T @ y\n    return w_hat\n\nw_hat_0 = 1/N * np.sum(y)\nw_hat_1 = fit_poly(x, y, 1)\nw_hat_3 = fit_poly(x, y, 3)\n```\n:::\n\n\n::: {#286ad778 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-6-output-1.png){width=1143 height=468}\n:::\n:::\n\n\nSo it looks like a third-order polynomial ($k$ = 3) is a good fit!\n\nHow do we know it's good?   Well, the training error $E(\\mathbf{w})$ is small.\n\n---\n\nBut ... can we make the training error __smaller__?\n\nYes, we can, if we increase the order of the polynomial.\n\nIn fact, we can reduce the error to zero!\n\nBy setting $k = 9$, we get the following polynomial fit to the data:\n\n::: {#1da09b22 .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-7-output-1.png){width=608 height=476}\n:::\n:::\n\n\nSo ... is the 9th order polynomial a \"better\" model for this dataset?\n\n---\n\n__Absolutely not!__\n\nWhy?\n\nInformally, the model is very \"wiggly\".  It seems unlikely that the real data generation process is governed by this curve.\n\nIn other words, we don't expect that, if we had __more__ data from the same source, that this model would do a good job of fitting the additional data.\n\nWe want the model to do a good job of predicting on __future__ data.  This is called\nthe model's __generalization__ ability.   \n\nThe 9th degree polynomial would seem to have poor generalization ability.\n\n---\n\nLet's assess generalization error.   For each polynomial (value of $k$) we will use new data, called __test__ data.  This is data that was __not__ used to train the model, but comes from the same source.\n\nIn our case, we know how the data is generated -- $\\sin(2\\pi x)$ plus noise -- so we can easily generate more.\n\n::: {#ff27503a .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-8-output-1.png){width=601 height=441}\n:::\n:::\n\n\nNotice that as we increase the order of the polynomial, the training error always declines.\n\nEventually, the training error reaches zero.\n\nHowever, the test error does not -- it reaches its smallest value at $k = 3$, a cubic polynomial.\n\nThe phenomenon in which training error declines, but testing error does not, is called __overfitting.__\n\nIn a sense we are fitting the training data \"too well\".\n\n---\n\nThere are two ways to think about overfitting:\n\n1. The number of parameters in the model is too large, compared to the size of the training data.   We can see this in the fact that we have only 10 training points, and the 9th order polynomial has 10 coefficents. \n\n2. The model is more complex than the actual phenomenon being modeled.  As a result, the model is not just fitting the underlying phenomenon, but also the noise in the data.\n\nThese suggest techniques we may use to avoid overfitting:\n\n1. Increase the amount of training data.  All else being equal, more training data is always better.\n\n2. Limit the complexity of the model.  Model complexity is often controlled via __hyperparameters__.\n\n## More Training Data\n\nIt's not necessarily true that a order-3 polynomial is best for this problem.\n\nBut the higher the order of polynomial we want to fit, the more data we need to avoid overfitting.\n\nHere we use an order-9 polynomial for increasing amounts of training data (N = 15, 50, 200):\n\n\n\n::: {#34743486 .cell execution_count=9}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-10-output-1.png){width=1143 height=470}\n:::\n:::\n\n\nWe see that with enough training data, the high order polynomial begins to capture the sine wave well.\n\n## Parameters and Hyperparameters\n\nMany times however, we cannot simply get more training data, or enough training data, to solve the overfitting problem. \n\nIn that case, we need to control the complexity of the model.\n\nNotice that model selection problem required us to choose a value $k$ that specifies the order of the polynomial model.\n\nAs already mentioned, the values $w_0, w_1, \\dots, w_k$ are called the __parameters__ of the model.\n\nIn contrast, $k$ is called a __hyperparameter.__\n\nA hyperparameter is a parameter that must be set first, before the (regular) parameters can be learned.\n\nHyperparameters are often used to control model complexity.\n\nHere, the hyperparameter $k$ controls the complexity (the order) of the polynomial model.\n\nSo, to avoid overfitting, we need to choose the proper value for the hyperparameter $k$.\n\nWe do that by __holding out data.__\n\n## Holding Out Data\n\nThe idea behind holding out data is simple.\n\nWe want to avoid overfitting, which occurs when a model fails to generalize -- that is, when it has high error on  data that it was not trained on.\n\nSo: we will hold some data aside, and __not__ use it for training the model, but instead use it for testing generalization ability.\n\nLet's assume that we have 20 data points to work with, stored in arrays `x` and `y`.\n\n`scikit-learn` has some functions that can be helpful. \n\n---\n\nWe will use `train_test_split()`:\n\n\n\n::: {#47464440 .cell execution_count=11}\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of items in training set: 10, in testing set: 10\n```\n:::\n:::\n\n\nNotice that `train_test_split()` splits the data __randomly.__\n\nThis will be important.\n\n---\n\n::: {#d8385e4a .cell execution_count=12}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-13-output-1.png){width=759 height=472}\n:::\n:::\n\n\nOur strategy will be:\n* For each possible value of the hyperparameter $k$:\n    * randomly split the data 5 times\n    * compute the mean testing and training error over the 5 random splits\n\nWhat are good possible values for the hyperparameter?  It can depend on the problem, and may involve trial and error.\n\n---\n\nThis strategy of trying all possible values of the hyperparameter is called a __grid search__.\n\n\n\n::: {#cbec2322 .cell execution_count=14}\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>k</th>\n      <th>split</th>\n      <th>Training Error</th>\n      <th>Testing Error</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0</td>\n      <td>1.147829</td>\n      <td>2.799292</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>1</td>\n      <td>1.700576</td>\n      <td>1.712716</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2</td>\n      <td>1.387723</td>\n      <td>2.133381</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>3</td>\n      <td>1.696808</td>\n      <td>1.695534</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>4</td>\n      <td>1.571746</td>\n      <td>1.989020</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>0</td>\n      <td>1.358846</td>\n      <td>2.603490</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>1</td>\n      <td>1.332199</td>\n      <td>2.082828</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2</td>\n      <td>0.747769</td>\n      <td>5.436927</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>3</td>\n      <td>1.559011</td>\n      <td>2.697498</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>4</td>\n      <td>1.677090</td>\n      <td>1.691438</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n---\n\nLet's plot the mean for each value of `k` and its standard error ($\\sigma/\\sqrt{n}$):\n\n::: {#3bf2f235 .cell execution_count=15}\n\n::: {.cell-output .cell-output-display}\n![](13-Learning-From-Data_files/figure-html/cell-16-output-1.png){width=576 height=434}\n:::\n:::\n\n\nFrom this plot we can conclude that, for this dataset, a polynomial of degree $k = 3$ shows the best generalization ability.\n\n## Hold Out Strategies\n\nDeciding how much, and which, data to hold out depends on a number of factors.\n\nIn general we'd like to give the training stage as much data as possible to work with.\n\nHowever, the more data we use for training, the less we have for testing -- which can decrease the accuracy of the testing stage.\n\nFurthermore, any single partition of the data can introduce dependencies -- any class that is overrepresented in the training data will be underrepresented in the test data.\n\nThere are two ways to address these problems:\n* Random subsampling\n* Cross-validation\n\n---\n\nIn __random subsampling__ one partitions the data randomly between train and test sets.  This is what the function `train_test_split()` does.\n\nThis ensures there is no dependence between the test and train sets.\n\nOne needs to perform a reasonable number of random splits - usually five at least.\n\n---\n\nIn __cross-validation__, the data is partitioned once, and then each partition is used as the test data once.\n\nThis ensures that all the data gets equal weight in the training and in the testing.\n\nWe divide the data into $k$ \"folds\".\n\n![](figs/L13-k-fold.png){width=\"50%\"}\n\n\nThe value of $k$ can vary up to the size of the dataset.\n\nThe larger $k$ we use, the more data is used for training, but the more folds must be evaluated, which increases the time required.\n\nIn the extreme case where $k$ is equal to the data size, then each data item is held out by itself; this is called \"leave-one-out\".\n\n## Conclusions\n\nWe have seen strategies that allow us to learn from data.\n\nThe strategies include:\n\n* Define a set of possible models\n* Define an error function that tells us when the model is predicting well\n* Using the error function, search through the space of models to find the best performer\n\nWe've also seen that there are some subtleties to this approach that must be dealt with to avoid problems:\n\n* Simply using the model that has lowest error on the training data will __overfit__.\n* We need to __hold out__ data to assess the generalization ability of each trained model.\n* We control model complexity using hyperparameters.\n* We choose the best hyperparameters based on performance on held out data.\n\n",
    "supporting": [
      "13-Learning-From-Data_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}