{
  "hash": "c1474cce7109a93c94cb8e9e26af27e6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Recommender Systems\njupyter: python3\nbibliography: references.bib\n---\n\n# Introduction\n\n## Introduction\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/20-Recommender-Systems-I.ipynb)\n\n\n\nToday, we look at a topic that has become enormously important: recommender systems.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n\nIn Part I, we will:\n\n* Define recommender systems\n* Review the challenges they pose\n* Discuss two classic methods:\n    * Collaborative Filtering\n    * Matrix Factorization\n\nIn Part II, we will:\n\n* Delve into more recent deep learning methods.\n\n:::\n::: {.column width=\"50%\"}\n\n\nThis section draws heavily on\n\n* These [slides](http://alex.smola.org/teaching/berkeley2012/slides/8_Recommender.pdf) by Alex Smola\n* _Matrix Factorization Techniques for Recommender Systems_, [@koren2009matrix]\n* _Collaborative Filtering with Temporal Dynamics_, [@koren2009collaborative]\n\n:::\n::::\n\n\n\n## What are Recommender Systems?\n\nThe concept of recommender systems emerged in the late 1990s / early 2000s as social life moved online:\n\n* online purchasing and commerce\n* online discussions and ratings\n* social information sharing\n\nIn these systems the amount of content was exploding and users were having a hard time finding things they were interested in.\n\n> Users wanted recommendations.\n\n---\n\nOver time, the problem has only gotten worse:\n\n![](figs/L20-netflix-options.png){fig-align=\"center\"}\n\n---\n\n![](figs/L20-amazon-options.png){fig-align=\"center\"}\n\n---\n\nAn enormous need has emerged for systems to help sort through products, services, and content items.\n\nThis often goes by the term __personalization.__\n\nSome examples (as of Fall 2024):\n    \n* Movie recommendation (Netflix ~6.5K movies and shows, YouTube ~14B videos)\n* Related product recommendation (Amazon ~600M products)\n* Web page ranking (Google >>100B pages)\n* Social content filtering (Facebook, Twitter)\n* Services (Airbnb, Uber, TripAdvisor)\n* News content recommendation (Apple News)\n* Priority inbox & spam filtering (Gmail)\n* Online dating (Match.com)\n\n---\n\nA more formal view:\n    \n* User - requests content\n* Objects - instances of content\n* Context - ratings, purchases, views, device, location, time, history\n* Interface - browser, mobile\n\n![](figs/L20-recsys-abstractly.png){fig-align=\"center\"}\n\n## Inferring Preferences\n\nUnfortunately, users generally have a hard time __explaining__ what types of\ncontent they prefer.   \n\nSome early systems worked by interviewing users to ask what they liked.  Those\nsystems did not work very well.\n\n::: aside\nA very interesting article about the earliest personalization systems is [User Modeling via Stereotypes](https://www.cs.utexas.edu/users/ear/CogSci.pdf) by Elaine Rich, dating from 1979.\n:::\n\n---\n\nInstead, modern systems work by capturing user's opinions about __specific__ items.\n\nThis can be done actively:\n\n* When a user is asked to **rate** a movie, product, or experience,\n\nor it can be done passively:\n\n* By noting which items a user **chooses** to purchase (for example).\n\n![](figs/L20-example-data.png){width=\"55%\" fig-align=\"center\"}\n\n\n## Challenges\n\n* The biggest issue is __scalability__: typical data for this problem is huge.\n  * Millions of objects\n  * 100s of millions of users\n* Changing user base\n* Changing inventory (movies, stories, goods)\n* Available features\n* Imbalanced dataset\n    * User activity / item reviews are power law distributed    \n\n::: aside\nThis data is a subset of the data presented in: \"From amateurs to connoisseurs:\nmodeling the evolution of user expertise through online reviews,\" by J. McAuley\nand J. Leskovec. WWW, 2013\n:::\n\n## Example\n\nLet's look at a dataset for testing recommender systems consisting of Amazon movie reviews:\n\nWe'll download a compressed pickle file containing the data if it is not already present.\n\n::: {#3e721057 .cell execution_count=3}\n``` {.python .cell-code}\n# This is a 647 MB file, delete it after use\nimport gdown\nurl = \"https://drive.google.com/uc?id=14GakA7oOjbQp7nxcGApI86WlP3GrYTZI\"\npickle_output = \"train.pkl.gz\"\n\nimport os.path\nif not os.path.exists(pickle_output):\n    gdown.download(url, pickle_output)\n```\n:::\n\n\nWe'll load the data into a pandas DataFrame.\n\n::: {#eab56af3 .cell execution_count=4}\n``` {.python .cell-code}\nimport gzip\nimport time\n\nstart_time = time.time()\nwith gzip.open(pickle_output, 'rb') as f:\n    df = pd.read_pickle(f)\nelapsed_time = time.time() - start_time\nprint(f\"Elapsed read time: {elapsed_time:.2f} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nElapsed read time: 2.85 seconds\n```\n:::\n:::\n\n\n---\n\nRun `df.info()` to see the column names and data types.\n\n::: {#fda22651 .cell execution_count=5}\n``` {.python .cell-code}\ndf.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1697533 entries, 0 to 1697532\nData columns (total 9 columns):\n #   Column                  Dtype  \n---  ------                  -----  \n 0   Id                      int64  \n 1   ProductId               object \n 2   UserId                  object \n 3   HelpfulnessNumerator    int64  \n 4   HelpfulnessDenominator  int64  \n 5   Score                   float64\n 6   Time                    int64  \n 7   Summary                 object \n 8   Text                    object \ndtypes: float64(1), int64(4), object(4)\nmemory usage: 116.6+ MB\n```\n:::\n:::\n\n\nwhere\n\n* HelpfulnessNumerator: The number of users who found the review helpful (the \"yes\" votes)\n* HelpfulnessDenominator: The total number of users who voted on whether the review was helpful (both \"yes\" and \"no\" votes)\n\n---\n\nNow we can count the number of users and movies:\n\n::: {#19a0a5cc .cell execution_count=6}\n``` {.python .cell-code}\nfrom IPython.display import display, Markdown\n\nn_users = df[\"UserId\"].unique().shape[0]\nn_movies = df[\"ProductId\"].unique().shape[0]\nn_reviews = len(df)\ndisplay(Markdown(f'There are:\\n'))\ndisplay(Markdown(f'* {n_reviews:,} reviews\\n* {n_movies:,} movies\\n* {n_users:,} users'))\n\ndisplay(Markdown(f'There are {n_users * n_movies:,} potential reviews, meaning sparsity of {(n_reviews/(n_users * n_movies)):0.4%}'))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nThere are:\n\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\n* 1,697,533 reviews\n* 50,052 movies\n* 123,960 users\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nThere are 6,204,445,920 potential reviews, meaning sparsity of 0.0274%\n:::\n:::\n\n\nwhere\n\n$$\n\\text{sparsity} \n= \\frac{\\text{\\# of reviews}}{\\text{\\# of users} \\times \\text{\\# of movies}}\n= \\frac{\\text{\\# of reviews}}{\\text{\\# of potential reviews}}\n$$\n\n## Reviews are Sparse\n\nOnly 0.02% of the reviews are available -- 99.98% of the reviews are missing.\n\n::: {#89a06fee .cell execution_count=7}\n``` {.python .cell-code}\ndisplay(Markdown(f'There are on average {n_reviews/n_movies:0.1f} reviews per movie' +\n     f' and {n_reviews/n_users:0.1f} reviews per user'))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nThere are on average 33.9 reviews per movie and 13.7 reviews per user\n:::\n:::\n\n\n## Sparseness is Skewed\n\nAlthough on average a movie receives 34 reviews, __almost all movies have even\nfewer reviews.__\n\n::: {#b35ca7ba .cell execution_count=8}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 4))  # Set the figure size\nreviews_per_movie = df.groupby('ProductId').count()['Id'].values\nfrac_below_mean = np.sum(reviews_per_movie < (n_reviews/n_movies))/len(reviews_per_movie)\nplt.plot(sorted(reviews_per_movie, reverse=True), '.-')\nxmin, xmax, ymin, ymax = plt.axis()\nplt.hlines(n_reviews/n_movies, xmin, xmax, 'r', lw = 3)\nplt.ylabel('Number of Ratings', fontsize = 14)\nplt.xlabel('Movie', fontsize = 14)\nplt.legend(['Number of Ratings', 'Average Number of Ratings'], fontsize = 14)\nplt.title(f'Amazon Movie Reviews\\nNumber of Ratings Per Movie\\n' +\n          f'{frac_below_mean:0.0%} of Movies Below Average', fontsize = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](20-Recommender-Systems-I_files/figure-revealjs/cell-8-output-1.png){width=830 height=434 fig-align='center'}\n:::\n:::\n\n\n---\n\nLikewise, although the average user writes 14 reviews, almost all users write even fewer reviews.\n\n::: {#3048d292 .cell execution_count=9}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 4))  # Set the figure size\nreviews_per_user = df.groupby('UserId').count()['Id'].values\nfrac_below_mean = np.sum(reviews_per_user < (n_reviews/n_users))/len(reviews_per_user)\nplt.plot(sorted(reviews_per_user, reverse=True), '.-')\nxmin, xmax, ymin, ymax = plt.axis()\nplt.hlines(n_reviews/n_users, xmin, xmax, 'r', lw = 3)\nplt.ylabel('Number of Ratings', fontsize = 14)\nplt.xlabel('User', fontsize = 14)\nplt.legend(['Number of Ratings', 'Average Number of Ratings'], fontsize = 14)\nplt.title(f'Amazon Movie Reviews\\nNumber of Ratings Per User\\n' +\n          f'{frac_below_mean:0.0%} of Users Below Average', fontsize = 16);\n```\n\n::: {.cell-output .cell-output-display}\n![](20-Recommender-Systems-I_files/figure-revealjs/cell-9-output-1.png){width=830 height=434 fig-align='center'}\n:::\n:::\n\n\n## Objective Function\n\nUltimately, our goal is to predict the rating that a user would give to an item.\n\nFor that, we need to define a loss or objective function.\n\nA typical objective function is root mean square error (RMSE)\n\n$$ \n\\text{RMSE} = \\sqrt{\\frac{1}{|S|} \\sum_{(i,u)\\in S} (\\hat{r}_{ui} - r_{ui})^2},\n$$\n\nwhere \n\n* $r_{ui}$ is the rating that user $u$ gives to item $i$, and \n* $S$ is the subset of items that have ratings.\n\nOK, now we know the problem and the data available.   How can we address the problem?\n\nThe earliest method developed is called __collaborative filtering.__\n\n# Colaborative Filtering\n\n## Collaborative Filtering\n\nThe central idea of collaborative filtering is that the set of known \nrecommendations can be considered to be a __bipartite graph.__\n\n![](figs/L20-bipartite.png){width=\"35%\" fig-align=\"center\"}\n\nThe nodes of the bipartite graph are __users__ ($U$) and __items__ ($V$).   \n\nEach edge corresponds to a known rating $r_{ui}.$\n\n---\n\nThen recommendations are formed by traversing or processing the bipartite graph.\n\n![](figs/L20-cf-basic-idea.png){width=\"60%\" fig-align=\"center\"}\n\nThere are at least two ways this graph can be used. \n\n---\n\nTwo ways to form a rating for item $(u, i)$: \n\n:::: {.fragment}\n1. Using **user-user similarity**:\n      * look at users that have similar item preferences to user $u$\n      * look at how those users rated item $i$\n::::  \n\n:::: {.fragment}\n⟹ <span style=\"background-color: yellow;\">Good for many users, fewer items.</span><br>\n(e.g., NetFix had ~280M subscribers, ~6.5K movies/shows)\n::::\n\n:::: {.fragment}\n2. Using **item-item similarity**:\n      * look at other items that have been liked by similar users as item $i$\n      * look at how user $u$ rated those items\n::::\n      \n:::: {.fragment}\n⟹ <span style=\"background-color: yellow;\">Good for many items, fewer users</span><br>\n(e.g. Amazon had ~300M accounts, ~600M products)\n::::\n\n## Item-Item CF\n\nFor item-item similarity, we'll look at **item-item Collaborative Filtering (CF).**\n\nThe questions are:\n\n::: {.incremental}\n* How do we judge \"similarity\" of items?\n* How do we form a predicted rating?\n:::\n\n---\n\nHere is another view of the ratings graph, this time as a matrix that includes missing entries:\n\n![](figs/L20-u-u-cf-1.png){width=\"60%\" fig-align=\"center\"}\n\n---\n\nLet's say we want to predict the value of this unknown rating:\n\n![](figs/L20-u-u-cf-2.png){width=\"60%\" fig-align=\"center\"}\n\n---\n\nWe'll consider two other items, namely items 3 and 6 (for example).\n\nNote that we are only interested in items that this user has rated.\n\n![](figs/L20-u-u-cf-3.png){width=\"60%\" fig-align=\"center\"}\n\n---\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](figs/L20-u-u-cf-3.png){width=\"100%\" fig-align=\"center\"}\n:::\n::: {.column width=\"50%\"}\nWe will discuss strategies for assessing similarity shortly. \n\nHow did we choose these two items?   \n\nWe used __$k$-nearest neighbors__.   Here $k$ = 2.\n\nFor now, let's just say we determine the similarities as:\n\n$$\ns_{13} = 0.2 \n$$\n\n$$\ns_{16} = 0.3 \n$$\n\n:::\n::::\n\n---\n\nThese similarity scores tell us how much weight to put on the rating of the other items.\n\n![](figs/L20-u-u-cf-4.png){width=\"50%\" fig-align=\"center\"}\n\nSo we can form a prediction of $\\hat{r}_{15}$ as:\n  \n$$\n\\hat{r}_{15} = \\frac{s_{13} \\cdot r_{35} + s_{16} \\cdot r_{65}}{s_{13} + s_{16}} = \\frac{0.2 \\cdot 2 + 0.3 \\cdot 3}{0.2 + 0.3} = 2.6 \n$$\n\n## Similarity\n\nHow should we assess similarity of items?\n\nA reasonable approach is to consider items similar if their ratings are\n__correlated:__, i.e., \n\n$$\\rho(X,Y) = \\frac{E\\left[(X-\\mu_X)(Y-\\mu_Y)\\right]}{\\sigma_X \\sigma_Y}.$$\n\nHowever, note that two items will not have ratings in the same positions.\n\n![](figs/L20-corr-support.png){width=\"60%\" fig-align=\"center\"}\n\nSo we want to compute correlation only over the users who rated both the items.\n\n## Example\n\n::: {.content-visible when-profile=\"slides\"}\n![](figs/L20-corr-support.png){width=\"60%\" fig-align=\"center\"}\n:::\n\nLet's put the ratings in python lists:\n\n::: {#ad8a2968 .cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\nfrom IPython.display import display, Markdown\n\nratings_item_i = [1, np.nan, np.nan, 5, 5, 3, np.nan, np.nan, np.nan, 4, 2, np.nan, np.nan, np.nan, np.nan, 4, np.nan, 5, 4, 1, np.nan]\nratings_item_j = [np.nan, np.nan, 4, 2, 5, np.nan, np.nan, 1, 2, 5, np.nan, np.nan, 2, np.nan, np.nan, 3, np.nan, np.nan, np.nan, 5, 4]\n\ndisplay(Markdown(f'Ratings for item $i$:\\n\\n{ratings_item_i}'))\ndisplay(Markdown(f'Ratings for item $j$:\\n\\n{ratings_item_j}'))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nRatings for item $i$:\n\n[1, nan, nan, 5, 5, 3, nan, nan, nan, 4, 2, nan, nan, nan, nan, 4, nan, 5, 4, 1, nan]\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nRatings for item $j$:\n\n[nan, nan, 4, 2, 5, nan, nan, 1, 2, 5, nan, nan, 2, nan, nan, 3, nan, nan, nan, 5, 4]\n:::\n:::\n\n\n## Example, continued\n\n::: {.content-visible when-profile=\"slides\"}\n![](figs/L20-corr-support.png){width=\"60%\" fig-align=\"center\"}\n:::\n\nLet's drop the non-common ratings:\n\n::: {#01613901 .cell execution_count=11}\n``` {.python .cell-code}\n# Create new lists where only numbers are kept that are not np.nan in both lists\nfiltered_ratings_item_i = [rating_i for rating_i, rating_j in zip(ratings_item_i, ratings_item_j) if not np.isnan(rating_i) and not np.isnan(rating_j)]\nfiltered_ratings_item_j = [rating_j for rating_i, rating_j in zip(ratings_item_i, ratings_item_j) if not np.isnan(rating_i) and not np.isnan(rating_j)]\n\ndisplay(Markdown(f'Common ratings for item $i$: {filtered_ratings_item_i}'))\ndisplay(Markdown(f'Common ratings for item $j$: {filtered_ratings_item_j}'))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nCommon ratings for item $i$: [5, 5, 4, 4, 1]\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nCommon ratings for item $j$: [2, 5, 5, 3, 5]\n:::\n:::\n\n\n## Example, continued\n\n::: {#ad86724f .cell execution_count=12}\n``` {.python .cell-code}\ndisplay(Markdown(f'Common ratings for item $i$: {filtered_ratings_item_i}'))\ndisplay(Markdown(f'Common ratings for item $j$: {filtered_ratings_item_j}'))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nCommon ratings for item $i$: [5, 5, 4, 4, 1]\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nCommon ratings for item $j$: [2, 5, 5, 3, 5]\n:::\n:::\n\n\nNow we can compute the Pearson correlation coefficient:\n\n::: {#69b0fe43 .cell execution_count=13}\n``` {.python .cell-code}\nrho = np.corrcoef(filtered_ratings_item_i, filtered_ratings_item_j)[0,1]\ndisplay(Markdown(f'Pearson correlation coefficient: {rho:0.2f}'))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown}\nPearson correlation coefficient: -0.43\n:::\n:::\n\n\nWhich is a _moderate negative correlation_, meaning that as item $i$ gets rated higher, item $j$ gets rated lower.\n\n::: {.content-visible when-profile=\"web\"}\n## Pearson Correlation Coefficient\n\nThe Pearson correlation coefficient, often denoted as $r$, is a measure of the\nlinear correlation between two variables $X$ and $Y$. It quantifies the degree\nto which a linear relationship exists between the variables. The value of $r$\nranges from -1 to 1, where:\n\n- $r = 1$ indicates a perfect positive linear relationship,\n- $r = -1$ indicates a perfect negative linear relationship,\n- $r = 0$ indicates no linear relationship.\n\nThe formula for the Pearson correlation coefficient is:\n\n$$\nr = \\frac{\\sum (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sqrt{\\sum (X_i - \\bar{X})^2 \\sum (Y_i - \\bar{Y})^2}}\n$$\n\nWhere:\n- $X_i$ and $Y_i$ are the individual sample points,\n- $\\bar{X}$ and $\\bar{Y}$ are the means of the $X$ and $Y$ samples, respectively.\n\nThe Pearson correlation coefficient is sensitive to outliers and assumes that the\nrelationship between the variables is linear and that the data is normally distributed.\n:::\n\n## Similarity for Binary Data\n\nIn some cases we will need to work with binary $r_{ui}$.  \n\nFor example, purchase histories on an e-commerce site, or clicks on an ad.\n\nIn this case, an appropriate replacement for Pearson $r$ is the \n**Jaccard similarity coefficient** or **Intersection over Union**.\n\n$$\nJ_{Sim}(\\mathbf{x}, \\mathbf{y}) = \\frac{|\\mathbf{x} \\cap \\mathbf{y}|}{|\\mathbf{x} \\cup \\mathbf{y}|}.\n$$\n\nSee the lecture on [similarity measures](05-Distances-Timeseries.qmd#norms).\n\n## Improving CF in the presence of bias\n\nOne problem with the story so far arises due to __bias__.\n\n* Some items are significantly higher or lower rated\n* Some users rate substantially higher or lower in general\n\nThese properties interfere with similarity assessment.  \n\nBias correction is crucial for CF recommender systems.\n\nWe need to include\n\n* Per-user offset\n* Per-item offset\n* Global offset\n\n## Representing biases\n\nHence we need to form a per-item bias of:\n    \n$$ \nb_{ui} = \\mu + \\alpha_u + \\beta_i \n$$\n\nwhere \n\n* $b_{ui}$ is the bias of user $u$ for item $i$.\n* $\\mu$ is the global average rating across all items and users.\n* $\\alpha_u$ is the offset of user $u$ and \n* $\\beta_i$ is the offset of item $i$.\n\nIf we gather all these elements together we can form: \n\n* $\\boldsymbol{\\alpha}$ an $n\\times 1$ vector of per-user offsets, and\n* $\\boldsymbol{\\beta}$ an $m\\times 1$ vector of per-item offsets.\n\n\n## Estimating biases\n\n::: {.content-visible when-profile=\"slides\"}\n$$ \nb_{ui} = \\mu + \\alpha_u + \\beta_i \n$$\n\n:::\n\nHow can we estimate the parameters $\\boldsymbol{\\alpha}$, $\\boldsymbol{\\beta}$, and $\\mu$?\n\nLet's assume for a minute that we had a fully-dense matrix of ratings $R$.\n\nRecall that each of the $m$ rows of $R$ represents an item and each of the $n$ columns represents a user.\n\n![](figs/L20-u-u-cf-1.png){width=\"40%\" fig-align=\"center\"}\n\n## Estimating biases, continued\n\nOne way to do this is to minimize the squared error between the ratings and the biases:\n\n$$\n\\min_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta},\\mu} \n\\Vert R - \\mathbf{1}\\boldsymbol{\\alpha}^T + \\boldsymbol{\\beta}\\mathbf{1}^T + \\mu1\\Vert^2 \n+ \\lambda(\\Vert\\boldsymbol{\\alpha}\\Vert^2 + \\Vert\\boldsymbol{\\beta}\\Vert^2).\n$$\n\nand include a regularization term to minimize the magnitude of the biases.\n\n* Here, bold-faced $\\mathbf{1}$ represents appropriately sized vectors of ones,\nand non-boldfaced $1$ is an $m\\times n$ matrix of ones.\n\n* So $\\mathbf{1}\\boldsymbol{\\alpha}^T$ is an $m\\times n$ matrix where each row is the bias for a user.\n\n* Similarly, $\\boldsymbol{\\beta}\\mathbf{1}^T$ is an $m\\times n$ matrix where each column is the bias for an item.\n\n* And $\\mu1$ is an $m\\times n$ matrix where each element is $\\mu$.\n\n::: {.content-visible when-profile=\"slides\"}\n\n## Estimating biases, continued\n\n$$\n\\min_{\\alpha,\\beta,\\mu} \n\\Vert R - \\mathbf{1}\\alpha^T + \\beta\\mathbf{1}^T + \\mu1\\Vert^2 \n+ \\lambda(\\Vert\\alpha\\Vert^2 + \\Vert\\beta\\Vert^2) \n$$\n:::\n\nWhile this is not a simple ordinary least squares problem, there is a strategy for solving it.\n\nAssume we hold $\\beta\\mathbf{1}^T$ and $\\mu1$ constant.  \n\nThen the remaining problem is \n\n$$\n\\min_{\\alpha} \\Vert R - \\mathbf{1}\\alpha^T \\Vert^2 + \\lambda \\Vert\\alpha\\Vert^2,\n$$\n\nwhich (for each column of $R$) is a standard regularized least squares problem\nsolved via [Ridge regression](./19-Regression-III-More-Linear.qmd#ridge-regression).\n\n## Aside: Ridge Regression\n\n**Ridge Regression** is a regularized least squares method that adds a penalty term to prevent overfitting.\n\n**Standard Least Squares:**\n$$\n\\min_{\\boldsymbol{\\beta}} \\Vert X\\boldsymbol{\\beta} - \\mathbf{y}\\Vert_2^2\n$$\n\n**Ridge Regression:**\n$$\n\\min_{\\boldsymbol{\\beta}} \\Vert X\\boldsymbol{\\beta} - \\mathbf{y}\\Vert_2^2 + c\\Vert\\boldsymbol{\\beta}\\Vert_2^2\n$$\n\nThe penalty term $c\\Vert\\boldsymbol{\\beta}\\Vert_2^2$ shrinks the coefficients $\\boldsymbol{\\beta}$ towards zero.\n\n---\n\n**Why Ridge Regression?**\n\n- Addresses **multicollinearity** (when features are highly correlated)\n- Prevents coefficient magnitudes from becoming too large\n- Always has a unique solution: $\\hat{\\boldsymbol{\\beta}} = (X^TX + cI)^{-1}X^T\\mathbf{y}$\n\n**The hyperparameter $c$:**\n\n- When $c = 0$: ordinary least squares\n- When $c \\rightarrow \\infty$: all coefficients shrink to zero\n- Choose $c$ via cross-validation to balance fitting vs. regularization\n\n## Back to Solving the problem\n\nThis sort of problem is called __jointly convex__ in that it is convex in each of the variables $\\alpha$, $\\beta$, and $\\mu$.\n\nThe strategy for solving is:\n    \n1. Hold $\\alpha$ and $\\beta$ constant, solve for $\\mu$.\n2. Hold $\\alpha$ and $\\mu$ constant, solve for $\\beta$.\n3. Hold $\\beta$ and $\\mu$ constant, solve for $\\alpha$.\n\nEach of the three steps will reduce the overall error.  As a result, we iterate over them until convergence.\n\n---\n\nThe last issue is that the matrix $R$ is not dense - in reality we only have a small subset of its entries.\n\nWe simply need to adapt the least-squares solution to only consider the entries in $R$ that we know.\n\nAs a result, the actual calculation is as follows...\n\n---\n\nStep 1:\n\n$$\n\\mu = \\frac{\\sum_{(u, i) \\in R} (r_{ui} - \\alpha_u - \\beta_i)}{|R|} \n$$\n\nStep 2: \n\n$$ \n\\alpha_u = \\frac{\\sum_{i \\in R(u)}(r_{ui} - \\mu - \\beta_i)}{\\lambda + |R(u)|} \n$$\n\nStep 3:\n    \n$$ \n\\beta_i = \\frac{\\sum_{u \\in R(i)}(r_{ui} - \\mu - \\alpha_u)}{\\lambda + |R(i)|} \n$$\n\nStep 4: If not converged, go to Step 1.\n\nHere $i \\in R(u)$ means the set of items rated by user $u$ and $u \\in R(i)$ means\nthe set of users who have rated item $i$ and $|R(u)|$ is the number of ratings.\n\n---\n\nNow that we have learned the biases, we can do a better job of estimating correlation:\n\n$$ \n\\hat{\\rho}_{ij} = \\frac{\\sum_{u\\in U(i,j)}(r_{ui} - b_{ui})(r_{uj}-b_{uj})} \n{\\sqrt{\\sum_{u\\in U(i,j)}(r_{ui} - b_{ui})^2\\sum_{u\\in U(i,j)}(r_{uj}-b_{uj})^2}},\n$$\n\nwhere \n\n* $b_{ui} = \\mu + \\alpha_u + \\beta_i$, and\n* $U(i,j)$ are the users who have rated both $i$ and $j$.\n\n---\n\nAnd using biases we can also do a better job of estimating ratings:\n\n$$ \n\\hat{r}_{ui} = b_{ui} + \\frac{\\sum_{j \\in n_k(i, u)} s_{ij}(r_{uj} - b_{uj})}{\\sum_{j \\in n_k(i, u)} s_{ij}},\n$$\n\nwhere \n\n* $b_{ui} = \\mu + \\alpha_u + \\beta_i$,\n* $n_k(i, u)$ are the $k$ nearest neighbors to $i$ that were rated by user $u$ and\n* $s_{ij}$ is the similarity between items $i$ and $j$, estimated as above.\n\n## Assessing CF\n\nThis completes the high level view of CF.\n\nWorking with user-user similarities is analogous.\n\nStrengths:\n\n* Essentially no training.\n    * The reliance on $k$-nearest neighbors helps in this respect.\n* Easy to update with new users, items, and ratings.\n* Explainable: \n    * \"We recommend _Minority Report_ because you liked _Blade Runner_ and _Total Recall._\"\n\nWeaknesses:\n\n* Accuracy can be a problem -- resulting in poor recommendations\n* Scalability can be a problem -- compute grows (think $k$-NN)\n\n# Matrix Factorization\n\n## Matrix Factorization\n\nNote that standard CF forces us to consider similarity among items, __or__ among\nusers, but does not take into account __both.__\n\nCan we use both kinds of similarity simultaneously?\n\nWe can't use both the rows and columns of the ratings matrix $R$ at the same\ntime -- the user and item vectors live in different vector spaces.\n\n---\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](figs/L10-Movie-Latent-Space.png){width=\"100%\" fig-align=\"center\" #fig-movie-latent-space}\n\n[@koren2009matrix]\n:::\n::: {.column width=\"50%\"}\nWhat we could try to do is find a __single__ vector space in which we represent\n__both__ users __and__ items, along with a similarity function, such that:\n\n* users who have similar item ratings are similar in the vector space\n* items who have similar user ratings are similar in the vector space\n* when a given user highly rates a given item, that user and item are similar in the vector space.\n:::\n::::\n\n:::: {.fragment}\nWe saw this idea previously, in an SVD lecture.\n\nThis new vector space is called a __latent__ space, and the user and item\nrepresentations are called __latent vectors.__\n\nThis notion of a shared latent space is also central to deep learning \nrecommender approaches [@naumov2019deep] we will look at later.\n::::\n\n---\n\nNow, however, we are working with a matrix which is only __partially observed.__\nThat is, we only know __some__ of the entries in the ratings matrix.\n\nNonetheless, we can imagine a situation like this:\n\n![](figs/L20-mf-1.png){.lightbox width=\"50%\" fig-align=\"center\"}\n\nwhere we decompose the ratings matrix $R$ into two matrices.\n\nWe want the product of the two matrices to be as close as possible \n__to the known values__ of the ratings matrix.\n\n---\n\nWhat this setup implies is that our similarity function is the __inner product.__\n\nWhich means that to predict an unknown rating, we take the __inner product of \nlatent vectors:__\n\n![](figs/L20-mf-2.png){width=\"60%\" fig-align=\"center\"}\n\nTaking, for example, the 2nd row of \"items\" and the 5th row of \"users\"...\n\n---\n\nWe have\n\n$$\n(-0.5 \\cdot -2)+(0.6 \\cdot 0.3)+(0.5 \\cdot 2.4) = 2.43,\n$$\n\nso:\n\n![](figs/L20-mf-3.png){width=\"60%\" fig-align=\"center\"}\n\n## Solving Matrix Factorization\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n![](figs/L20-mf-1.png){.lightbox width=\"100%\" fig-align=\"center\"}\n:::\n::: {.column width=\"60%\"}\nNotice that in this case we've decided that the factorization should be rank 3,\ni.e., low-rank.\n\nSo we want something like an SVD.\n\n(Recall that SVD gives us the most-accurate-possible low-rank factorization of a matrix).\n:::\n::::\n\nHowever, we can't use the SVD algorithm directly, because we don't know all the entries in $R$. \n\n> Indeed, the unseen entries in $R$ are exactly what we want to predict.\n\n---\n\nHere is what we want to solve: \n    \n$$\n\\min_{U,V} \\Vert (R - UV^T)_S\\Vert^2 + \\lambda(\\Vert U\\Vert^2 + \\Vert V\\Vert^2) \n$$\n\nwhere:\n\n* $R$ is $m\\times n$, \n* $U$ is the $m\\times k$ items matrix,\n* $V$ is the $n\\times k$ users matrix and\n* $k$ is the rank of the factorization and dimensionality of the latent space.\n\nThe $(\\cdot)_S$ notation means that we are only considering the _subset_ of\nmatrix entries that correspond to known reviews (the set $S$).\n\nNote that as usual, we add $\\ell_2$ penalization to avoid overfitting\n([Ridge regression](./19-Regression-III-More-Linear.qmd#ridge-regression)).\n\n---\n\n::: {.content-visible when-profile=\"slides\"}\n$$\n\\min_{U,V} \\Vert (R - UV^T)_S\\Vert^2 + \\lambda(\\Vert U\\Vert^2 + \\Vert V\\Vert^2) \n$$\n:::\n\nOnce again, this problem is __jointly convex__ in that it is convex in each of the variables $U$ and $V$.\n\nIn particular, if we hold either $U$ or $V$ constant, then the result is a simple\nridge regression.\n\n---\n\n::: {.content-visible when-profile=\"slides\"}\n$$\n\\min_{U,V} \\Vert (R - UV^T)_S\\Vert^2 + \\lambda(\\Vert U\\Vert^2 + \\Vert V\\Vert^2) \n$$\n:::\n\n\nSo one commonly used algorithm for this problem is called __alternating least squares (ALS):__\n    \n1. Hold $U$ constant, and solve for $V$\n2. Hold $V$ constant, and solve for $U$\n3. If not converged, go to Step 1.\n\nThe only thing we've left out at this point is how to deal with the missing entries of $R$.  \n\nIt's not hard, but the details aren't that interesting, so we'll give you code instead!\n\n## ALS in Practice\n\nThe entire Amazon reviews dataset is too large to work with easily, and it is too sparse. \n\nHence, we will take the densest rows and columns of the matrix.\n\n::: {#eccf1a1f .cell execution_count=14}\n``` {.python .cell-code}\nprint(df.shape)\n\n# The densest columns: products with more than 50 reviews\npids = df.groupby('ProductId').count()['Id']\nhi_pids = pids[pids > 50].index\n\n# reviews that are for these products\nhi_pid_rec = [r in hi_pids for r in df['ProductId']]\n\n# the densest rows: users with more than 50 reviews\nuids = df.groupby('UserId').count()['Id']\nhi_uids = uids[uids > 50].index\n\n# reviews that are from these users\nhi_uid_rec = [r in hi_uids for r in df['UserId']]\n\n# The result is a list of booleans equal to the number of rewviews\n# that are from those dense users and movies\ngoodrec = [a and b for a, b in zip(hi_uid_rec, hi_pid_rec)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1697533, 9)\n```\n:::\n:::\n\n\nNow we create a $\\textnormal{UserID} \\times \\textnormal{ProductID}$ matrix from these reviews.\n\nMissing entries will be filled with NaNs.\n\n::: {#bbabde0b .cell execution_count=15}\n``` {.python .cell-code}\ndense_df = df.loc[goodrec]\ngood_df = dense_df.loc[~df['Score'].isnull()]\nR = good_df.pivot_table(columns = 'ProductId', index = 'UserId', values = 'Score')\n```\n:::\n\n\n---\n\nAnd we can look at a small part of the matrix:\n\n::: {#c53b0344 .cell execution_count=16}\n``` {.python .cell-code}\nR.iloc[900:905, 1000:1004]\n```\n\n::: {.cell-output .cell-output-display execution_count=119}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>ProductId</th>\n      <th>1417024917</th>\n      <th>1417030321</th>\n      <th>1417030976</th>\n      <th>1417054069</th>\n    </tr>\n    <tr>\n      <th>UserId</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>A1WLZYEOIL1HLT</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>A1WNJVA59HLMO5</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>A1WR12AC35R3K6</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>A1WSFHRBY2ZD1R</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>A1WUMTJOASEL5F</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n---\n\nWe'll use code from the [Antidote Data Framework](https://github.com/rastegarpanah/antidote-data-framework) to do the matrix factorization and ALS. We have local copies \n[recommender_MF.py](recommender_MF.py), [recommender_als.py](recommender_als.py)\nand [recommender_lmafit.py](recommender_lmafit.py) in our repository.\n\n::: {#48e2b7b8 .cell execution_count=17}\n``` {.python .cell-code code-fold=\"false\"}\n# Import local python package MF.py\nimport recommender_MF as MF\n\n# Instantiate the model\n# We are pulling these hyperparameters out of the air -- that's not the right way to do it!\nRS = MF.als_MF(rank = 20, lambda_ = 1)\n```\n:::\n\n\n<br>\n\n::: {#6a652487 .cell execution_count=18}\n``` {.python .cell-code code-fold=\"false\"}\n%time pred, error = RS.fit_model(R)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 24 s, sys: 118 ms, total: 24.1 s\nWall time: 24 s\n```\n:::\n:::\n\n\n<br>\n\n::: {#e13a21cc .cell execution_count=19}\n``` {.python .cell-code code-fold=\"false\"}\nprint(f'RMSE on visible entries (training data): {np.sqrt(error/R.count().sum()):0.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRMSE on visible entries (training data): 0.343\n```\n:::\n:::\n\n\n---\n\nAnd we can look at a small part of the predicted ratings matrix and see that it is a dense matrix:\n\n::: {#919083bf .cell execution_count=20}\n``` {.python .cell-code}\nprint(f'Shape of predicted ratings matrix: {pred.shape}')\npred.iloc[900:905, 1000:1004]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape of predicted ratings matrix: (3677, 7244)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=123}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>ProductId</th>\n      <th>1417024917</th>\n      <th>1417030321</th>\n      <th>1417030976</th>\n      <th>1417054069</th>\n    </tr>\n    <tr>\n      <th>UserId</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>A1WLZYEOIL1HLT</th>\n      <td>3.374718</td>\n      <td>4.104916</td>\n      <td>4.219042</td>\n      <td>5.402325</td>\n    </tr>\n    <tr>\n      <th>A1WNJVA59HLMO5</th>\n      <td>3.470308</td>\n      <td>5.736709</td>\n      <td>5.306202</td>\n      <td>4.309822</td>\n    </tr>\n    <tr>\n      <th>A1WR12AC35R3K6</th>\n      <td>4.007515</td>\n      <td>4.262276</td>\n      <td>4.590415</td>\n      <td>3.147474</td>\n    </tr>\n    <tr>\n      <th>A1WSFHRBY2ZD1R</th>\n      <td>4.030337</td>\n      <td>4.484953</td>\n      <td>3.857923</td>\n      <td>5.263364</td>\n    </tr>\n    <tr>\n      <th>A1WUMTJOASEL5F</th>\n      <td>2.818730</td>\n      <td>3.302549</td>\n      <td>4.571714</td>\n      <td>5.893641</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n---\n\n::: {#33e7f440 .cell execution_count=21}\n``` {.python .cell-code}\n## todo: hold out test data, compute oos error\n\n# We create a mask of the known entries, then calculate the indices of the known\n# entries, then split that data into training and test sets.\n\n# Create a mask for the known entries\nRN = ~R.isnull()\n\n# Get the indices of the known entries\nvisible = np.where(RN)\n\n# Split the data into training and test sets\nimport sklearn.model_selection as model_selection\nX_train, X_test, Y_train, Y_test = model_selection.train_test_split(visible[0], visible[1], test_size = 0.1)\n```\n:::\n\n\nJust for comparison's sake, let's check the performance of $k$-NN on this dataset.\n\nAgain, this is only on the training data -- so overly optimistic for sure.\n\nAnd note that this is a subset of the full dataset -- the subset that is \"easiest\" to predict due to density.\n\n::: {#1c5bbcdf .cell execution_count=22}\n``` {.python .cell-code}\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import mean_squared_error\n\n# Drop the columns that are not features\nX_train = good_df.drop(columns=['Id', 'ProductId', 'UserId', 'Text', 'Summary'])\n\n# The target is the score\ny_train = good_df['Score']\n\n# Using k-NN on features HelpfulnessNumerator, HelpfulnessDenominator, Score, Time\nmodel = KNeighborsClassifier(n_neighbors=3).fit(X_train, y_train)\n%time y_hat = model.predict(X_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 2.32 s, sys: 19.9 ms, total: 2.34 s\nWall time: 2.32 s\n```\n:::\n:::\n\n\n::: {#b8b97a33 .cell execution_count=23}\n``` {.python .cell-code}\nprint(f'RMSE on visible entries (test set): {np.sqrt(mean_squared_error(y_train, y_hat)):.3f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRMSE on visible entries (test set): 0.649\n```\n:::\n:::\n\n\n## Assessing Matrix Factorization\n\nMatrix Factorization per se is a good idea.    \nHowever, many of the improvements we've discussed for CF apply to MF as well.\n\nTo illustrate, we'll look at some of the successive improvements used by the\nteam that won the Netflix prize (\"BellKor's Pragmatic Chaos\").\n\nWhen the prize was announced, the Netflix supplied solution achieved an RMSE of 0.951.\n\nBy the end of the competition (about 3 years), the winning team's solution achieved RMSE of 0.856.\n\nLet's restate our MF objective in a way that will make things clearer:\n\n$$\n\\min_{U, V} \\sum_{(u, i)\\in S}(r_{ui} - u_u^Tv_i)^2 + \\lambda(\\Vert U\\Vert^2 + \\Vert V\\Vert^2) \n$$\n\nwhere we have written out the vector $\\ell_2$ norm as the summation.\n\n## 1. Adding Biases\n\nIf we add biases:\n$$ \n\\min_{U, V} \\sum_{(u, i)\\in S}(r_{ui} - (\\mu + \\alpha_u + \\beta_i + u_u^Tv_i)^2 \n+ \\lambda(\\Vert U\\Vert^2 + \\Vert V\\Vert^2 + \\Vert \\alpha\\Vert^2 + \\Vert \\beta \\Vert^2) \n$$\n\n---\n\nwe see improvements in accuracy:\n\n![Matrix factorization models’ accuracy. The plots show the root-mean-square error of each of four individual factor models (lower is better). Accuracy improves when the factor model’s dimensionality (denoted by numbers on the charts) increases. In addition, the more refined factor models, whose descriptions involve more distinct sets of parameters, are more accurate.](figs/L20-netflix-1.png){width=\"70%\" fig-align=\"center\" #fig-mf}\n\n## 2. Who Rated What?\n\nIn reality, ratings are not provided __at random.__\n\nTake note of which users rated the same movies (ala CF) and use this information.\n\n![](figs/L20-netflix-2.png){width=\"70%\" fig-align=\"center\"}\n\n---\n\n![](figs/L20-netflix-3.png){width=\"70%\" fig-align=\"center\"}\n\n## 3. Ratings Change Over Time\n\nOlder movies tend to get higher ratings!\n\n![](figs/L20-netflix-4.png){width=\"60%\" fig-align=\"center\"}\n\n---\n\nIf we add time-varying biases:\n\n$$\n\\min_{U, V} \\sum_{(u, i)\\in S}(r_{ui} - (\\mu + \\alpha_u(t) + \\beta_i(t) + u_u^Tv_i(t))^2 \n+ \\lambda(\\Vert U\\Vert^2 + \\Vert V\\Vert^2 + \\Vert \\alpha\\Vert^2 + \\Vert \\beta \\Vert^2) \n$$\n\n---\n\nwe see further improvements in accuracy:\n\n![](figs/L20-netflix-5.png){width=\"50%\" fig-align=\"center\"}\n\nTo estimate these billions of parameters, we cannot use alternating least squares or any linear algebraic method.\n\nWe need to use gradient descent (which we covered previously).\n\n\n## Recap\n\n* Introduction to recommender systems and their importance in modern society.\n* Explanation of collaborative filtering (CF) and its two main approaches: user-user similarity and item-item similarity.\n* Discussion on the challenges of recommender systems, including scalability and data sparsity.\n* Introduction to matrix factorization (MF) as an improvement over CF, using latent vectors and alternating least squares (ALS) for optimization.\n* Practical implementation of ALS for matrix factorization on a subset of Amazon movie reviews.\n\n## References\n\n::: {#refs}\n:::\n\n",
    "supporting": [
      "20-Recommender-Systems-I_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}