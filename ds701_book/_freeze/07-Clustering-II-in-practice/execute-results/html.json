{
  "hash": "3228b864ced47a1818303b41a676c2ba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Clustering In Practice\njupyter: python3\n---\n\n## Clustering in Practice\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tools4ds/DS701-Course-Notes/blob/main/ds701_book/jupyter_notebooks/07-Clustering-II-in-practice.ipynb)\n\n\n...featuring $k$-means\n\nToday we'll do an extended example showing $k$-means clustering in practice and in the context of the python libraries\n__`scikit-learn.`__\n\n`scikit-learn` is the main python library for machine learning functions.\n\nOur goals are to learn:\n\n::: {.incremental}\n* How clustering is used in practice\n* Tools for evaluating the quality of a clustering\n* Tools for assigning meaning or labels to a cluster\n* Important visualizations\n* A little bit about feature extraction for text\n:::\n\n# Visualization\n\n## Training wheels: Synthetic data\n\nGenerally, when learning about or developing a new unsupervised method, it's a \ngood idea to try it out on a dataset in which you already know the \"right\" answer.\n\nOne way to do that is to generate synthetic data that has some known properties.\n \nAmong other things, `scikit-learn` contains tools for generating synthetic data\nfor testing.\n\nWe'll use [datasets.make_blobs](https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_blobs.html).\n\n::: {#7b019af4 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\nimport sklearn.datasets as sk_data\nX, y, gt_centers = sk_data.make_blobs(n_samples=100, centers=3, n_features=30,\n                          center_box=(-10.0, 10.0), random_state=0, return_centers=True)\n```\n:::\n\n\nLet's check the shapes of the returned values:\n\n::: {#452e1c82 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\nprint(\"X.shape: \", X.shape)\nprint(\"y.shape: \", y.shape)\nprint(\"gt_centers: \", gt_centers.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nX.shape:  (100, 30)\ny.shape:  (100,)\ngt_centers:  (3, 30)\n```\n:::\n:::\n\n\n::: {.notes}\n`datasets.makeblobs` takes as arguments:\n\n- `n_samples`: The number of samples to generate\n- `n_features`: The number of features, or in other words the dimensionality of\neach sample\n- `center_box`: The bounds of the cluster centers\n- `random_state`: The random seed for reproducibility\n- `return_centers`: A boolean flag, True to return the centers so that we have ground truth\n:::\n\n## Visualize the Data\n\nTo get a sense of the raw data we can inspect it.\n\nFor statistical visualization, a good library is [Seaborn](https://seaborn.pydata.org/).\n\nLet's plot the `X` data as a matrix\n[heatmap](https://seaborn.pydata.org/generated/seaborn.heatmap.html), \nwhere every row is a data point and the columns are the features.\n\n::: {#d335774d .cell execution_count=4}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Set the figure size to make the plot smaller\nplt.figure(figsize=(7, 5))  # Adjust the width and height as needed\nsns.heatmap(X, xticklabels = False, yticklabels = False, linewidths = 0, cbar = True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-4-output-1.png){width=518 height=389 fig-align='center'}\n:::\n:::\n\n\n---\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n\n::: {#68380f6c .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-5-output-1.png){width=317 height=241}\n:::\n:::\n\n\n:::\n::: {.column width=\"60%\"}\nGeometrically, these points live in a __30 dimensional__ space, so we cannot directly visualize their geometry.  \n\nThis is a __big problem__ that you will run into time and again!\n\nWe will discuss methods for visualizing high dimensional data later on.\n\nFor now, we will use a method that can turn a set of pairwise distances into an approximate 2-D representation __in some cases.__\n:::\n::::\n\n---\n\nSo let's compute the pairwise distances, _in 30 dimensions_, for visualization purposes.\n\nWe can compute all pairwise distances in a single step using the `scikit-learn` [`metrics.euclidean_distances`](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.euclidean_distances.html) function:\n\n::: {#f89bdf49 .cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\nimport sklearn.metrics as metrics\neuclidean_dists = metrics.euclidean_distances(X)\n# euclidean_dists\n```\n:::\n\n\n::: {#200f716c .cell execution_count=7}\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix shape is:  (100, 100)\n```\n:::\n:::\n\n\nLet's look at the upper left and lower right corners of the distances matrix.\n\n::: {#78ffae8a .cell execution_count=8}\n\n::: {.cell-output .cell-output-stdout}\n```\nUpper left 3x3:\n[[ 0.   47.74 45.19]\n [47.74  0.   43.67]\n [45.19 43.67  0.  ]]\n\n...\nLower right 3x3:\n[[ 0.    8.19 41.82]\n [ 8.19  0.   43.41]\n [41.82 43.41  0.  ]]\n```\n:::\n:::\n\n\nNote that this produces a $100\\times100$ symmetric matrix where the diagonal\nis all zeros (distance from itself).\n\n---\n\nLet's look at a histogram of the distances.\n\n::: {#bc119d69 .cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sklearn.metrics as metrics\n\n# Compute the pairwise distances\neuclidean_dists = metrics.euclidean_distances(X)\n\n# Extract the lower triangular part of the matrix, excluding the diagonal\nlower_triangular_values = euclidean_dists[np.tril_indices_from(euclidean_dists, k=-1)]\n\n# Plot the histogram\nplt.figure(figsize=(10, 6))\nplt.hist(lower_triangular_values, bins=30, edgecolor='black')\nplt.title('Histogram of Lower Diagonal Values of Euclidean Distances')\nplt.xlabel('Distance')\nplt.ylabel('Frequency')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-9-output-1.png){width=825 height=523}\n:::\n:::\n\n\n::: {.notes}\nRemember that these are the pairwise distances, _in 30 dimensions_. So at least\nwith this dataset we see a clean separation presumably between inter-cluster\ndistances and intra-cluster distances.\n\nHow would the curse of dimensionality affect this? We discuss the curse of\ndimensionality later in the course.\n:::\n## Visualizing with MDS\n\nThe idea behind [Multidimensional Scaling (MDS)](https://en.wikipedia.org/wiki/Multidimensional_scaling) is given a pairwise distance (or dissimilarity) matrix:\n\n:::: {.incremental}\n* Find a set of coordinates in 1, 2 or 3-D space that approximates those distances as well as possible.\n* The points that are close (or far) in high dimensional space should be close (or far) in the reduced dimension space.\n::::\n\n## MDS Continued\n\nNote that there are two forms of MDS:\n\n* Metric MDS, of which Classical MDS is a special case, and has a closed form solution\n  based on the eigenvectors of the centered distance matrix. \n    * $O(n^3)$ time complexity and $O(n^2)$ space complexity.\n* Non-Metric MDS, which tries to find a non-parametric monotonic relationship\n  between the dissimilarities and the target coordinates through an iterative approach. \n    * $O(n^2)$ time complexity.\n\nMDS may not always work well if, for example the dissimilarities\nare not well modeled by a metric like Euclidean distance.\n\n\n## MDS Visualization Result\n\n::: {#cell-code-mds .cell execution_count=10}\n``` {.python .cell-code}\nimport sklearn.manifold\nimport matplotlib.pyplot as plt\nmds = sklearn.manifold.MDS(n_components=2, max_iter=3000, eps=1e-9, random_state=0,\n                   dissimilarity = \"precomputed\", n_jobs = 1)\nfit = mds.fit(euclidean_dists)\npos = fit.embedding_\nplt.scatter(pos[:, 0], pos[:, 1], s=8)\nplt.axis('square');\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/code-mds-output-1.png){#code-mds width=426 height=411}\n:::\n:::\n\n\nSo we can see that, although our data lives in 30 dimensions, we can get a\nsense of how the points are clustered by approximately placing the points into\ntwo dimensions.\n\n---\n\nOut of curiosity, we can visualize the pairwise distance matrix using a heatmap.\n\n::: {#14a18818 .cell execution_count=11}\n``` {.python .cell-code code-fold=\"false\"}\nsns.heatmap(euclidean_dists, xticklabels=False, yticklabels=False, linewidths=0, \n            square=True )\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-11-output-1.png){width=471 height=397 fig-align='center'}\n:::\n:::\n\n\n# Applying $k$-means\n\n## Applying  $k$-Means\n\nThe Python package `scikit-learn` has a huge set of tools for unsupervised learning generally, and clustering specifically.  \n\nThese are in __`sklearn.cluster.`__\n\nThere are 3 functions in all the clustering classes, \n\n* **`fit()`**: builds the model from the training data.\n    * For $k$-means, this function find the centroids.\n* **`predict()`**: assigns labels to the data after building the models. \n    * For $k$-means this assigns the cluster number to a point.\n* **`fit_predict()`**: calls fit and predict in a single step.\n\n---\n\nLet's go back to the original 30-D synthetic dataset and apply $k$-means and\nshow the cluster numbers.\n\n::: {#ccb9d365 .cell execution_count=12}\n``` {.python .cell-code}\nfrom sklearn.cluster import KMeans\nkmeans = KMeans(init = 'k-means++', n_clusters = 3, n_init = 100, random_state=0)\ny_prime = kmeans.fit_predict(X)\nprint(y_prime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 2 1 0 1 1 0 1 2 0 2 0 1 2 2 0 2 1 2 1 2 0 1 1 0 2 2 2 2 0 2 0 2 1 2\n 1 2 1 1 1 0 2 0 2 0 1 0 2 2 0 0 0 0 2 0 1 1 2 0 2 1 0 0 1 2 0 0 1 1 1 0 0\n 2 0 1 0 1 0 1 1 1 0 2 2 1 0 0 2 0 1 1 2 0 2 2 1 1 2]\n```\n:::\n:::\n\n\nFor comparisons, here are the original cluster numbers.\n\n::: {#4d076833 .cell execution_count=13}\n``` {.python .cell-code}\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 2 1 1 2 0 2 2 0 2 1 0 1 0 2 1 1 0 1 2 1 2 1 0 2 2 0 1 1 1 1 0 1 0 1 2 1\n 2 1 2 2 2 0 1 0 1 0 2 0 1 1 0 0 0 0 1 0 2 2 1 0 1 2 0 0 2 1 0 0 2 2 2 0 0\n 1 0 2 0 2 0 2 2 2 0 1 1 2 0 0 1 0 2 2 1 0 1 1 2 2 1]\n```\n:::\n:::\n\n\nNote that the $k$-means labels are different than the ground truth labels. \n\n---\n\nWe can remap the values according to\n\n$$\n\\begin{align*}\n0 &\\rightarrow 0 \\\\\n1 &\\rightarrow 2 \\\\\n2 &\\rightarrow 1.\n\\end{align*}\n$$\n\n::: {#70a2b13a .cell execution_count=14}\n``` {.python .cell-code}\n# Remap y_prime\nremap = {0: 0, 1: 2, 2: 1}\ny_prime_remapped = np.vectorize(remap.get)(y_prime)\nprint(\"Remapped y_prime:\")\nprint(y_prime_remapped)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRemapped y_prime:\n[0 2 1 1 2 0 2 2 0 2 1 0 1 0 2 1 1 0 1 2 1 2 1 0 2 2 0 1 1 1 1 0 1 0 1 2 1\n 2 1 2 2 2 0 1 0 1 0 2 0 1 1 0 0 0 0 1 0 2 2 1 0 1 2 0 0 2 1 0 0 2 2 2 0 0\n 1 0 2 0 2 0 2 2 2 0 1 1 2 0 0 1 0 2 2 1 0 1 1 2 2 1]\n```\n:::\n:::\n\n\n::: {#ffe343fc .cell execution_count=15}\n``` {.python .cell-code}\n# Calculate the number of mismatched entries\nmismatches = np.sum(y != y_prime_remapped)\n\n# Calculate the percentage of mismatched entries\ntotal_entries = len(y)\npercentage_mismatched = (mismatches / total_entries) * 100\n\nprint(f\"Percentage of mismatched entries: {percentage_mismatched:.2f}%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPercentage of mismatched entries: 0.00%\n```\n:::\n:::\n\n\nTo reiterate, mismatches are 0.00%.\n\n---\n\nAll the tools in `scikit-learn` are implemented as Python objects.\n\nRecall that the general sequence for using a tool from `scikit-learn` is:\n\n* create the object, probably with some hyperparameter settings or initialization,\n* run the method, generally by using the `fit()` function, and\n* examine the results, which are generally property variables of the object.\n\n::: {#d0bc7d4f .cell execution_count=16}\n``` {.python .cell-code code-fold=\"false\"}\ncentroids = kmeans.cluster_centers_\nlabels = kmeans.labels_\ninertia = kmeans.inertia_\n```\n:::\n\n\nAnd we see the resulting cluster inertia.\n\n::: {#1857dcf9 .cell execution_count=17}\n``` {.python .cell-code}\nprint(f'Clustering inertia: {inertia:0.1f}.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClustering inertia: 2733.8.\n```\n:::\n:::\n\n\n## Visualizing the Results of Clustering\n\nLet's visualize the results.  We'll do that by reordering the data items according to their cluster.\n\n::: {#84fa8921 .cell execution_count=18}\n``` {.python .cell-code}\nimport numpy as np\nidx = np.argsort(labels)\nrX = X[idx, :]\nsns.heatmap(rX, xticklabels = False, yticklabels = False, linewidths = 0)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-18-output-1.png){width=707 height=389 fig-align='center'}\n:::\n:::\n\n\nYou can clearly see the feature similarities of the samples in the same cluster.\n\n---\n\nWe can also sort the pairwise distance matrix.\n\n::: {#fa03a143 .cell execution_count=19}\n``` {.python .cell-code}\nrearranged_dists = euclidean_dists[idx,:][:,idx]\nsns.heatmap(rearranged_dists, xticklabels = False, yticklabels = False, linewidths = 0, square = True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-19-output-1.png){width=471 height=397 fig-align='center'}\n:::\n:::\n\n\nHere again, you can see the inter-cluster sample distances are small.\n\n\n# Cluster Evaluation\n\n## Cluster Evaluation\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\nHow do we know whether the clusters we get represent \"real\" structure in our data?\n\nConsider a dataset of 100 points _uniformly distributed_ in the unit square.\n\n> Question: Does that look uniformly distributed to you?\n:::\n::: {.column width=\"50%\"}\n\n::: {#f982235b .cell execution_count=20}\n``` {.python .cell-code}\nimport pandas as pd\nnp.random.seed(42)\nunif_X = np.random.default_rng().uniform(0, 1, 500)\nunif_Y = np.random.default_rng().uniform(0, 1, 500)\ndf = pd.DataFrame(np.column_stack([unif_X, unif_Y]), columns = ['X', 'Y'])\ndf.plot('X', 'Y', kind = 'scatter', \n        colorbar = False, xlim = (0, 1), ylim = (0, 1), \n        figsize = (4, 4))\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-20-output-1.png){width=376 height=361 fig-align='center'}\n:::\n:::\n\n\n:::\n::::\n\n\n\n---\n\nAfter running $k$-means on this data:\n\n::: {#74a577ad .cell execution_count=21}\n``` {.python .cell-code}\nkmeans = KMeans(init = 'k-means++', n_clusters = 3, n_init = 500, random_state=0)\ndf['label'] = kmeans.fit_predict(df[['X', 'Y']])\ndf.plot('X', 'Y', kind = 'scatter', c = 'label', \n        colormap='viridis', colorbar = False, \n        xlim = (0, 1), ylim = (0, 1), \n        figsize = (4, 4))\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-21-output-1.png){width=376 height=361 fig-align='center'}\n:::\n:::\n\n\n:::: {.fragment}\nThe point is: clustering algorithms output some \"clustering\" of the data.\n::::\n\n---\n\nThe question is, does the clustering reflect __real__ structure?\n\n:::: {.fragment}\nGenerally we encounter two problems:\n::::\n\n::: {.incremental}\n* Are there *real* clusters in the data?\n* If so, *how many* clusters are there?\n:::\n\n:::: {.fragment}\nThere is often no definitive answer to either of these questions.\n\nYou will often need to use your judgment in answering them.\n::::\n\n::: {.content-hidden}\n\n## Cluster Evaluations\n\n(Under Development)\n\n### With Ground Truth Data\n\n* How to evaluate clustering algorithms when you have ground truth data\n    * how do you align labels?\n    * different accuracy measures\n\n### Without Ground Truth Data\n\n* Can you make guesses to the underlying probability distributions to show that\n  it is non-uniform?\n\n## Clustering Metrics\n\n[sklearn clustering examples](https://scikit-learn.org/stable/auto_examples/cluster/index.html)\n\n- [sklearn performance evaluation guide](https://scikit-learn.org/stable/modules/clustering.html#clustering-performance-evaluation)\n- [sklearn metrics](https://scikit-learn.org/stable/api/sklearn.metrics.html)\n    - [sklearn clustering metrics](https://scikit-learn.org/stable/api/sklearn.metrics.html#module-sklearn.metrics.cluster)\n        - [sklearn rand score](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.rand_score.html)\n- [sklearn example: adjustment for chance in clustering performance evaluation](https://scikit-learn.org/stable/auto_examples/cluster/plot_adjusted_for_chance_measures.html)\n\n:::\n\n## Clustering Metrics\n\nBroadly separated into two categories.\n\n:::: {.fragment}\n1. **Ground truth based metrics**\n\nWe'll look at (Adjusted) Rand Index.\n\n::::\n\n:::: {.fragment}\n> Note: Even with ground truth labels, we can't apply accuracy measures like we will\n> see in supervised learning approaches since clustering algorithms don't try to\n> match exact labels, but rather group similar items together.\n\n::::\n\n:::: {.fragment}\n2. **Internal cluster metrics (no ground truth external labels)**\n\nWe'll look at Silhouette Coefficient.\n::::\n\n\n## Rand Index (named after William M. Rand)\n\n* Compare a proposed clustering, $C$, with ground truth labels, $T$.\n* Look at the ratio, compared to total possible pairs, of pairs of points that are either\n    * in the same cluster in both $T$ and $C$, or\n    * in different clusters in both $T$ and $C$.\n\n> Question: What are pairs not in either category?\n\n## Rand Index Formula\n\nThe formula for the Rand Index is:\n\n$$\n\\text{RI}(T,C) = \\frac{a+b}{n \\choose 2},\n$$\n\n- where $a$ is the number of pairs of points that are _in the same cluster_ in both $T$ and $C$, and\n- $b$ is the number of pairs of points that are _in different clusters_ in both $T$ and $C$.\n\nWe normalize the sum by the combinatorial number of pairs of points, $n \\choose 2$.\n\nThe __Rand Index__ is a value that falls in the range $[0, 1]$.\n\n## Aside: n choose 2\n\n* From combinatorics\n\n**\"n choose 2\"** (written as $n \\choose 2$) represents the number of ways to choose 2 items from a set of n items, where the order doesn't matter.\n\n#### Formula\n\n$$\nC(n,2) = n! / (2! × (n-2)!) = n(n-1)/2\n$$\n\n#### What it means\n\n- It counts the number of **pairs** you can form from n items\n- Order doesn't matter (so {A,B} is the same as {B,A})\n- No repetition (you can't choose the same item twice)\n\n#### Examples\n\n- **3 choose 2**: From items {A, B, C}, you can form pairs {A,B}, {A,C}, {B,C} = **3 pairs**\n- **4 choose 2**: From items {A, B, C, D}, you can form pairs {A,B}, {A,C}, {A,D}, {B,C}, {B,D}, {C,D} = **6 pairs**\n- **5 choose 2**: From items {A, B, C, D, E}, you can form **10 pairs**\n\n## Rand Index Example 1\n\nLet's proceed by way of example.\n\nWe'll create another synthetic dataset of 3 clusters, so we have ground truth\nlabels $T$.\n\n::: {#0484a2e9 .cell execution_count=22}\n``` {.python .cell-code code-fold=\"false\"}\nX_rand, y_rand = sk_data.make_blobs(n_samples=[100, 300, 50], \n                                    centers = [[1.2, 2.4],[1.5, 3], [1.8, 3.5]], \n                                    n_features = 2,\n                                    center_box = (-10.0, 10.0), \n                                    cluster_std = [.2, .3, .2], \n                                    random_state = 0)\ndf_rand_gt = pd.DataFrame(np.column_stack([X_rand[:, 0], X_rand[:, 1], y_rand]), columns = ['X', 'Y', 'label'])\ndf_rand_clust = df_rand_gt.copy()\nkmeans = KMeans(init = 'k-means++', n_clusters = 3, n_init = 100, random_state=0)\ndf_rand_clust['label'] = kmeans.fit_predict(df_rand_gt[['X', 'Y']])\ndf_rand_clust['label'] = df_rand_clust['label'].replace({0: 1, 1: 2, 2: 0})\n```\n:::\n\n\n## Rand Index Example 1: Plotting the Results\n\nWe then run $k$-means with 3 clusters to on the datasets to get labels $C$ and plot the results:\n\n::: {#bc1b84a8 .cell execution_count=23}\n``` {.python .cell-code}\nfigs, axs = plt.subplots(1, 2, figsize = (12, 5))\ndf_rand_gt.plot('X', 'Y', \n                kind = 'scatter', \n                c = 'label', \n                colormap='viridis', \n                ax = axs[0],\n                colorbar = False)\naxs[0].set_title('Ground Truth (T)')\naxs[0].set_axis_off()\n\ndf_rand_clust.plot('X', 'Y', \n                    kind = 'scatter', \n                    c = 'label', \n                    colormap='viridis', \n                    ax = axs[1],\n                    colorbar = False)\naxs[1].set_title('Clustering (C)')\naxs[1].set_axis_off()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-23-output-1.png){width=912 height=409 fig-align='center'}\n:::\n:::\n\n\n::: {#20dca913 .cell execution_count=24}\n``` {.python .cell-code}\nprint(\"The Rand index is: \", metrics.rand_score(df_rand_gt[\"label\"], df_rand_clust[\"label\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Rand index is:  0.5814798317248205\n```\n:::\n:::\n\n\n## Adjusted Rand Index\n\nHow do we know whether a particular Rand Index (RI) score is significant?\n\nWe might compare it to the RI for a __random__ assignment of points to labels.\n\nThis leads to the __Adjusted Rand Index.__\n\n\n## The Adjusted Rand Index\n\nTo *calibrate* the Rand Index this way, we use the expected Rand Index of random labels, denoted $E[\\text{RI}]$.   \n\nThe Expected Rand Index considers $C$ to be a clustering that has the same cluster sizes as $T$, but the labels are assigned at random.\n\n:::: {.fragment}\nUsing that, we define the adjusted Rand index as a simple __rescaling__ of RI:\n\n$$\n\\text{ARI} = \\frac{\\text{RI} - E[\\text{RI}]}{1 - E[\\text{RI}]}\n$$\n\nWhere $1$ represents $\\max(\\text{RI})$, the maximum possible Rand Index.\n\n$E[\\text{RI}]$ can be computed using combinatorics (we'll omit the derivation).\n\nThe below code block computes and prints the adjusted Rand index for the example on the previous slide.\n\n::: {#9ec99ac4 .cell execution_count=25}\n``` {.python .cell-code}\nprint(\"The adjusted Rand index is: \", metrics.adjusted_rand_score(df_rand_gt[\"label\"], df_rand_clust[\"label\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe adjusted Rand index is:  0.16578149408651535\n```\n:::\n:::\n\n\n::::\n\n## Rand Index Example 2\n\nLet's consider again our 3-cluster dataset with known labels `y`.\n\n::: {#dc86c2cf .cell execution_count=26}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(5, 4))  # Adjust the width and height as needed\nsns.heatmap(X, xticklabels = False, yticklabels = False, linewidths = 0)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-26-output-1.png){width=388 height=315 fig-align='center'}\n:::\n:::\n\n\n## Rand Index Example 2: Evaluating the Results\n\nHere is the Rand Index and adjusted Rand Index, when using $k$-means to cluster this dataset for 1 to 10 clusters:\n\n::: {#9e1c56f9 .cell execution_count=27}\n``` {.python .cell-code}\ndef ri_evaluate_clusters(X, max_clusters, ground_truth):\n    ri = np.zeros(max_clusters+1)\n    ri[0] = 0\n    ari = np.zeros(max_clusters+1)\n    ari[0] = 0\n    for k in range(1,max_clusters+1):\n        kmeans = KMeans(init='k-means++', n_clusters=k, n_init=10)\n        kmeans.fit_predict(X)\n\n        ri[k] = metrics.rand_score(kmeans.labels_, ground_truth)\n        ari[k] = metrics.adjusted_rand_score(kmeans.labels_, ground_truth)\n    return ri, ari\n    \nri, ari = ri_evaluate_clusters(X, 10, y)\nplt.figure(figsize=(6, 4))\nplt.plot(range(1, len(ri)), ri[1:], 'ro-', range(1, len(ari)), ari[1:], 'b*-')\nplt.xlabel('Number of clusters')\nplt.title('$k$-means Clustering Compared to Known Labels')\nplt.ylabel('Index value')\nplt.legend(['RI', 'ARI'])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-27-output-1.png){width=514 height=377 fig-align='center'}\n:::\n:::\n\n\n## RI vs ARI\n\nThe ARI provides a more nuanced evaluation of clustering similarity compared to the RI by accounting for the chance grouping of elements. Here are the key differences:\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n__Rand Index (RI)__\n\n- Measures Agreement: The RI measures the agreement between two clusterings by considering all pairs of elements and counting pairs that are either in the same or different clusters in both clusterings.\n- Range: The RI ranges from 0 to 1, where 1 indicates perfect agreement and 0 indicates no agreement.\n:::\n::: {.column width=\"50%\"}\n__Adjusted Rand Index (ARI)__\n\n- Adjusts for Chance: The ARI adjusts the RI by considering the expected similarity that might occur by random chance. This adjustment makes the ARI a more reliable measure, especially when dealing with random or unbalanced clusterings.\n- Range: The ARI can take values from -1 to 1. A value of 0 indicates that the clustering is no better than random, while a value of 1 indicates perfect agreement. Negative values indicate that the clustering is worse than random.\n:::\n::::\n\n## Information Provided by ARI\n\nThe ARI corrects for the fact that some level of agreement between clusterings can occur purely by chance. This makes it a more accurate measure of the true similarity between clusterings.\n\nThe ARI’s range allows for a clearer interpretation of clustering performance. An ARI of 0 means the clustering is no better than random, which is more informative than an RI of 0.5, which might still be influenced by chance.\n\nThe ARI allows for better comparison between different clustering results, as it normalizes the index to account for the chance agreement.\n\n## Deciding on the Number of Clusters\n\nThe second question we face in evaluating a clustering is how many clusters are present.\n\nIn practice, to use $k$-means or most other clustering methods, one must choose $k$, the number of clusters, via some process.\n\n## Inspecting Clustering Error\n\nThe first thing you might do is to look at the $k$-means objective function  and see if it levels off after a certain point.\n\nRecall that the $k$-means objective can be considered the clustering \"error\".\n\nIf the error stops going down, that would suggest that the clustering is not improving as the number of clusters is increased.\n\nLet's calculate the error for 1-11 clusters.\n\n::: {#b12dc8d3 .cell execution_count=28}\n``` {.python .cell-code code-fold=\"false\"}\nerror = np.zeros(11)\nfor k in range(1,11):\n    kmeans = KMeans(init='k-means++', n_clusters = k, n_init = 10)\n    kmeans.fit_predict(X)\n    error[k] = kmeans.inertia_\n```\n:::\n\n\n::: {.content-visible when-profile=\"slides\"}\n## Inspecting Clustering Error\n:::\n\nFor our synthetic data, here is the $k$-means objective, as a function of $k$:\n\n::: {#e31144d0 .cell execution_count=29}\n``` {.python .cell-code}\nplt.plot(range(1, len(error)), error[1:], 'o-')\nplt.xlabel('Number of clusters')\nplt.title(r'$k$-means clustering performance of synthetic data')\nplt.ylabel('Error')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-29-output-1.png){width=833 height=450}\n:::\n:::\n\n\n::: {.callout-warning}\nThis synthetic data is not at all typical. You will almost never see such a sharp change in the error function as we see here.\n:::\n\n---\n\nLet's create a function to evaluate clusters for later use.\n\n::: {#0586187d .cell execution_count=30}\n``` {.python .cell-code code-fold=\"false\"}\ndef evaluate_clusters(X,max_clusters):\n    error = np.zeros(max_clusters+1)\n    error[0] = 0\n    for k in range(1,max_clusters+1):\n        kmeans = KMeans(init='k-means++', n_clusters=k, n_init=10)\n        kmeans.fit_predict(X)\n        error[k] = kmeans.inertia_\n    return error\n```\n:::\n\n\n## Silhouette Coefficient\n\nUsually, the ground truth labels are not known.\n\n:::: {.fragment}\nIn that case, evaluation must be performed using the model itself.\n::::\n\n:::: {.fragment}\nRecall our definition of clustering: \n::::\n\n:::: {.fragment}\n> a grouping of data objects, such that the objects within a group are similar (or near) to one another and dissimilar\n> (or far) from the objects in other groups.\n::::\n\n:::: {.fragment}\nThis suggests a metric that could evaluate a clustering: comparing the distances between points within a cluster, to the\ndistances between points in different clusters.\n::::\n\n## Silhouette Coefficient\n\nThe Silhouette Coefficient is an example of such an evaluation, where a higher Silhouette Coefficient score relates to a\nmodel with \"better defined\" clusters. \nWe'll use [`sklearn.metrics.silhouette_score`](https://scikit-learn.org/stable/modules/clustering.html#silhouette-coefficient)\n\n::: {.incremental}\n- Let $a$ be the mean distance between a data point and all other points in the same cluster.\n- Let $b$ be the mean distance between a data point and all other points in the next nearest cluster. \n:::\n\n\n:::: {.fragment}\nThen the **Silhouette Coefficient** for a point is\n\n$$ \ns = \\frac{b-a}{\\max(a, b)}.\n$$\n\nwhere $\\max(a, b)$ is the larger of the two mean distances.\n\n::::\n\n\n \n## Why This Makes Sense\n\nThe **max(a, b)** normalization ensures the coefficient is always between -1 and 1:\n\n- **If a < b** (good clustering): Point is closer to its own cluster\n  - max(a, b) = b\n  - s = (b - a) / b = 1 - (a/b) → **positive (0 to 1)**\n\n- **If a > b** (poor clustering): Point is closer to other clusters  \n  - max(a, b) = a\n  - s = (b - a) / a = (b/a) - 1 → **negative (-1 to 0)**\n\n- **If a = b** (boundary): Point is equidistant\n  - s = 0\n\nThis creates a scale where:\n\n- **+1** = perfectly clustered (a = 0, b > 0)\n- **0** = on the boundary (a = b)  \n- **-1** = completely misclustered (b = 0, a > 0)\n\n## Overall Silhouette Score\n\n\nThe overall silhouette score is the average of the silhouette coefficient for each data point.\n\n$$\n(1/n) \\sum_{i=1}^n s_i\n$$\n\n\n## Silhouette Score for our synthetic data\n\nWe can calculate the Silhouette Score for our synthetic data:\n\n::: {#a9ebe4ed .cell execution_count=31}\n``` {.python .cell-code}\nsc = metrics.silhouette_score(X, labels, metric='euclidean')\nprint('Silhouette Score:', sc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSilhouette Score: 0.8319348841402534\n```\n:::\n:::\n\n\n::: {.content-visible when-profile=\"slides\"}\n## Silhouette Coefficient\n:::\n\nWe can also evaluate it for 2-10 clusters and plot the results:\n\n::: {#b1fce324 .cell execution_count=32}\n``` {.python .cell-code}\ndef sc_evaluate_clusters(X, max_clusters, n_init, seed):\n    s = np.zeros(max_clusters+1)\n    s[0] = 0\n    s[1] = 0\n    for k in range(2, max_clusters+1):\n        kmeans = KMeans(init='k-means++', n_clusters = k, n_init = n_init, random_state = seed)\n        kmeans.fit_predict(X)\n        s[k] = metrics.silhouette_score(X, kmeans.labels_, metric = 'euclidean')\n    return s\n\ns = sc_evaluate_clusters(X, 10, 10, 1)\nplt.plot(range(2, len(s)), s[2:], 'o-')\nplt.xlabel('Number of Clusters')\nplt.title('$k$-means clustering performance on synthetic data')\nplt.ylabel('Silhouette Score')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-32-output-1.png){width=812 height=450}\n:::\n:::\n\n\n:::: {.fragment}\nAgain, these results are more perfect than typical. \n\nBut the general idea is to look for a local maximum in the Silhouette Coefficient as the potential number of clusters.\n::::\n\n# k-means++\n\n## k-means++ initialization\nProposed in 2007 by David Arthur and Sergei Vassilvitskii.\n\nK-means++ improves the initialization of cluster centers to enhance the quality of the final clustering results. Here’s how it works.\n\n- Choose an initial centroid $c_1$ randomly.\n- Choose the next centroid $c_i$ with probability proportional to the squared distances to each data point.\n    - This ensures that new centroids are spread out across the data space.\n- Repeat this process until $k$ centroids have been selected.\n\nOnce the initial centroids are chosen, the standard k-means algorithm is applied.\n\nThe main advantage of k-means++ over randomly assigning points is that it reduces the likelihood of poor clustering results due to suboptimal initial centroids. This often leads to faster convergence and better overall clustering quality.\n\n## Visualizing K-means++ Initialization Probability\n\nLet's create a visualization that demonstrates how K-means++ selects the second centroid based on the squared distances from the first selected point:\n\n::: {#83b5db25 .cell execution_count=33}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport numpy as np\n\n# Create a small uniformly distributed 2D dataset\nnp.random.seed(42)\nn_points = 100\nX = np.random.uniform(-5, 5, (n_points, 2))\n\n# Select the first centroid randomly (simulate k-means++ first step)\nfirst_centroid = X[0]  # For demonstration, we'll use the first point\n\n# Calculate squared distances from all points to the first centroid\ndistances_squared = np.sum((X - first_centroid)**2, axis=1)\n\n# Normalize to get probabilities (proportional to squared distances)\nprobabilities = distances_squared / np.sum(distances_squared)\n\n# Create 3D plot\nfig = plt.figure(figsize=(12, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the 2D points\nax.scatter(X[:, 0], X[:, 1], c='lightblue', s=30, alpha=0.6, label='Data points')\n\n# Highlight the first centroid\nax.scatter(first_centroid[0], first_centroid[1], c='red', s=100, marker='*', \n           label='First centroid', edgecolors='darkred', linewidth=2)\n\n# Create 3D visualization where z-axis represents probability\n# We'll create a grid to show the probability surface\nx_range = np.linspace(X[:, 0].min(), X[:, 0].max(), 50)\ny_range = np.linspace(X[:, 1].min(), X[:, 1].max(), 50)\nX_grid, Y_grid = np.meshgrid(x_range, y_range)\n\n# Calculate probability for each grid point\ngrid_distances_squared = (X_grid - first_centroid[0])**2 + (Y_grid - first_centroid[1])**2\ngrid_probabilities = grid_distances_squared / np.sum(grid_distances_squared)\n\n# Plot the probability surface\nsurf = ax.plot_surface(X_grid, Y_grid, grid_probabilities, \n                      alpha=0.3, cmap='viridis', \n                      linewidth=0, antialiased=True)\n\n# Add the actual data points with their probabilities as z-values\nax.scatter(X[:, 0], X[:, 1], probabilities, c='darkblue', s=20, alpha=0.8)\n\n# Add colorbar\nfig.colorbar(surf, ax=ax, shrink=0.5, aspect=20, label='Selection Probability')\n\n# Set labels and title\nax.set_xlabel('X coordinate')\nax.set_ylabel('Y coordinate')\nax.set_zlabel('Selection Probability')\nax.set_title('K-means++ Initialization Probability\\n(Probability ∝ Squared Distance from First Centroid)')\n\n# Add legend\nax.legend()\n\n# Set viewing angle for better visualization\nax.view_init(elev=20, azim=45)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-33-output-1.png){width=879 height=759}\n:::\n:::\n\n\nThis 3D visualization shows:\n\n- **Light Blue points**: The uniformly distributed 2D dataset\n- **Red star**: The first randomly selected centroid\n- **Surface and Dark Blue points**: The probability of selecting each point as the second centroid\n- **Z-axis**: Represents the selection probability (proportional to squared distance from first centroid)\n\nAs you can see, points farther from the first centroid have higher selection probability, which helps ensure that the second centroid is well-separated from the first one.\n\n# Real Data Clustering Example\n\n## Taking the Training Wheels Off: Real Data\n\nAs a classic \"real world\" example, we'll use the \n[\"20 Newsgroup\" data](https://scikit-learn.org/stable/datasets/real_world.html#the-20-newsgroups-text-dataset)\nprovided as example data in scikit-learn.\n\nWe borrow code from this sklearn\n[example](https://scikit-learn.org/stable/auto_examples/text/plot_document_clustering.html).\n\nLet's load the data and count the number of documents and categories.\n\n::: {#a2fbce93 .cell execution_count=34}\n``` {.python .cell-code code-fold=\"false\"}\nfrom sklearn.datasets import fetch_20newsgroups\n\n# just use the following categories\ncategories = ['comp.os.ms-windows.misc', 'sci.space', 'rec.sport.baseball']\n\nnews_data = fetch_20newsgroups(\n    remove = ('headers', 'footers', 'quotes'),\n    subset = 'train', \n    categories = categories,\n    shuffle = True,\n    random_state = 42)\n\nlabels = news_data.target\nunique_labels, category_sizes = np.unique(labels, return_counts=True)\ntrue_k = unique_labels.shape[0]\n\nprint(f\"{len(news_data.data)} documents - {true_k} categories\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1781 documents - 3 categories\n```\n:::\n:::\n\n\n## Example Document\n\nHere is an example of one of the documents:\n\n::: {#e4458454 .cell execution_count=35}\n``` {.python .cell-code}\nprint(news_data.data[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\nEarly to mid June.\n\n\nIf they think the public wants to see it they will carry it. Why not\nwrite them and ask? You can reach them at:\n\n\n                          F: NATIONAL NEWS MEDIA\n\n\nABC \"World News Tonight\"                 \"Face the Nation\"\n7 West 66th Street                       CBS News\nNew York, NY 10023                       2020 M Street, NW\n212/887-4040                             Washington, DC 20036\n                                         202/457-4321\n\nAssociated Press                         \"Good Morning America\"\n50 Rockefeller Plaza                     ABC News\nNew York, NY 10020                       1965 Broadway\nNational Desk (212/621-1600)             New York, NY 10023\nForeign Desk (212/621-1663)              212/496-4800\nWashington Bureau (202/828-6400)\n                                         Larry King Live TV\n\"CBS Evening News\"                       CNN\n524 W. 57th Street                       111 Massachusetts Avenue, NW\nNew York, NY 10019                       Washington, DC 20001\n212/975-3693                             202/898-7900\n\n\"CBS This Morning\"                       Larry King Show--Radio\n524 W. 57th Street                       Mutual Broadcasting\nNew York, NY 10019                       1755 So. Jefferson Davis Highway\n212/975-2824                             Arlington, VA 22202\n                                         703/685-2175\n\"Christian Science Monitor\"\nCSM Publishing Society                   \"Los Angeles Times\"\nOne Norway Street                        Times-Mirror Square\nBoston, MA 02115                         Los Angeles, CA 90053\n800/225-7090                             800/528-4637\n\nCNN                                      \"MacNeil/Lehrer NewsHour\"\nOne CNN Center                           P.O. Box 2626\nBox 105366                               Washington, DC 20013\nAtlanta, GA 30348                        703/998-2870\n404/827-1500\n                                         \"MacNeil/Lehrer NewsHour\"\nCNN                                      WNET-TV\nWashington Bureau                        356 W. 58th Street\n111 Massachusetts Avenue, NW             New York, NY 10019\nWashington, DC 20001                     212/560-3113\n202/898-7900\n\n\"Crossfire\"                              NBC News\nCNN                                      4001 Nebraska Avenue, NW\n111 Massachusetts Avenue, NW             Washington, DC 20036\nWashington, DC 20001                     202/885-4200\n202/898-7951                             202/362-2009 (fax)\n\n\"Morning Edition/All Things Considered\"  \nNational Public Radio                    \n2025 M Street, NW                        \nWashington, DC 20036                     \n202/822-2000                             \n\nUnited Press International\n1400 Eye Street, NW\nWashington, DC 20006\n202/898-8000\n\n\"New York Times\"                         \"U.S. News & World Report\"\n229 W. 43rd Street                       2400 N Street, NW\nNew York, NY 10036                       Washington, DC 20037\n212/556-1234                             202/955-2000\n212/556-7415\n\n\"New York Times\"                         \"USA Today\"\nWashington Bureau                        1000 Wilson Boulevard\n1627 Eye Street, NW, 7th Floor           Arlington, VA 22229\nWashington, DC 20006                     703/276-3400\n202/862-0300\n\n\"Newsweek\"                               \"Wall Street Journal\"\n444 Madison Avenue                       200 Liberty Street\nNew York, NY 10022                       New York, NY 10281\n212/350-4000                             212/416-2000\n\n\"Nightline\"                              \"Washington Post\"\nABC News                                 1150 15th Street, NW\n47 W. 66th Street                        Washington, DC 20071\nNew York, NY 10023                       202/344-6000\n212/887-4995\n\n\"Nightline\"                              \"Washington Week In Review\"\nTed Koppel                               WETA-TV\nABC News                                 P.O. Box 2626\n1717 DeSales, NW                         Washington, DC 20013\nWashington, DC 20036                     703/998-2626\n202/887-7364\n\n\"This Week With David Brinkley\"\nABC News\n1717 DeSales, NW\nWashington, DC 20036\n202/887-7777\n\n\"Time\" magazine\nTime Warner, Inc.\nTime & Life Building\nRockefeller Center\nNew York, NY 10020\n212/522-1212\n\n```\n:::\n:::\n\n\n## Feature Extraction\n\nWe've discussed a bit the challenges of feature engineering.   \n\nOne of the most basic issues concerns how to encode categorical or text data in a form usable by algorithms that expect\nnumeric input.\n\nThe starting point is to note that one can encode a set using a binary vector with one component for each potential set\nmember.  \n\n## Bag of Words\n\nThe so-called _bag of words_ encoding for a document is to treat the document as a _multiset_ of words.\n\n> A _multiset_ is like a set but allows for multiple instances of each element.\n\nThat is, we simply count how many times each word occurs. It is a \"bag\" because all the order of the words in the\ndocument is lost.\n\nSurprisingly, we can still tell a lot about the document even without knowing its word ordering.\n\n## Bag of Words Example\n\nConsider this short document (one paragraph):\n\n\"The quick brown fox jumps over the lazy dog. The dog sleeps soundly at noon.\"\n\nWe ignore word order and count occurrences of each word.\n\n::: {#5e931a7e .cell execution_count=36}\n``` {.python .cell-code code-fold=\"false\"}\nimport re\nfrom collections import Counter\n\ndoc = (\n    \"The quick brown fox jumps over the lazy dog. \"\n    \"The dog sleeps soundly at noon.\"\n)\n\n# simple tokenization: lowercase and keep alphabetic words\ntokens = re.findall(r\"[a-zA-Z']+\", doc.lower())\ncounts = Counter(tokens)\n\n# show vocabulary and frequencies sorted by word\nsorted_counts = sorted(counts.items())\nsorted_counts\n```\n\n::: {.cell-output .cell-output-display execution_count=184}\n```\n[('at', 1),\n ('brown', 1),\n ('dog', 2),\n ('fox', 1),\n ('jumps', 1),\n ('lazy', 1),\n ('noon', 1),\n ('over', 1),\n ('quick', 1),\n ('sleeps', 1),\n ('soundly', 1),\n ('the', 3)]\n```\n:::\n:::\n\n\nYou can also view the words and counts as separate vectors:\n\n::: {#0cd77696 .cell execution_count=37}\n``` {.python .cell-code}\nvocabulary = [w for w, c in sorted_counts]\nfrequencies = [c for w, c in sorted_counts]\nprint('words   =', vocabulary)\nprint('counts  =', frequencies)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwords   = ['at', 'brown', 'dog', 'fox', 'jumps', 'lazy', 'noon', 'over', 'quick', 'sleeps', 'soundly', 'the']\ncounts  = [1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 3]\n```\n:::\n:::\n\n\n## Term Frequencies\n\nCounting the number of times each word occurs in a document yields a vector of __term frequencies.__\n\nHowever, simply using the \"bag of words\" directly has a number of drawbacks. First of all, large documents will have\nmore words than small documents.   \n\nHence it often makes sense to normalize the frequency vectors.\n\n$\\ell_1$ or $\\ell_2$ normalization are common.\n\n## Bag of Words: Normalization\n\n\nWe can scale raw counts so documents of different lengths are comparable.\n\n::: {#56068907 .cell execution_count=38}\n``` {.python .cell-code code-fold=\"true\"}\nimport math\n\ntry:\n    sorted_counts  # reuse if already defined above\nexcept NameError:\n    import re\n    from collections import Counter\n    doc = (\n        \"The quick brown fox jumps over the lazy dog. \"\n        \"The dog sleeps soundly at noon.\"\n    )\n    tokens = re.findall(r\"[a-zA-Z']+\", doc.lower())\n    from collections import Counter\n    counts = Counter(tokens)\n    sorted_counts = sorted(counts.items())\n\nvocabulary = [w for w, c in sorted_counts]\ncounts_vec = [c for w, c in sorted_counts]\n\n# L1 normalization: divide by sum of counts\ntotal = sum(counts_vec)\nl1 = [c / total for c in counts_vec]\n\n# L2 normalization: divide by Euclidean norm\nnorm2 = math.sqrt(sum(c*c for c in counts_vec))\nl2 = [c / norm2 for c in counts_vec]\n\nprint('words =', vocabulary)\nprint('\\nL1-normalized counts =', l1)\nprint('\\nL2-normalized counts =', l2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwords = ['at', 'brown', 'dog', 'fox', 'jumps', 'lazy', 'noon', 'over', 'quick', 'sleeps', 'soundly', 'the']\n\nL1-normalized counts = [0.06666666666666667, 0.06666666666666667, 0.13333333333333333, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.06666666666666667, 0.2]\n\nL2-normalized counts = [0.20851441405707477, 0.20851441405707477, 0.41702882811414954, 0.20851441405707477, 0.20851441405707477, 0.20851441405707477, 0.20851441405707477, 0.20851441405707477, 0.20851441405707477, 0.20851441405707477, 0.20851441405707477, 0.6255432421712244]\n```\n:::\n:::\n\n\n## Tf-idf\n\nNext, as noted in __scikit-learn__:\n\n::: {.incremental}\n* In a large text corpus, some words will be very frequent (e.g. “the”, “a”, “is” in English) hence carrying very\nlittle meaningful information about the actual contents of the document. \n* If we were to feed the direct count data directly to a classifier those very frequent terms would overshadow the\nfrequencies of rarer yet more interesting terms.\n* In order to re-weight the count features into floating point values suitable for usage by a classifier it is very\ncommon to use the **tf–idf transform.**\n* __Tf__ means __term-frequency__ while __tf–idf__ means __term-frequency times inverse document-frequency.__\n* This is originally a term weighting scheme developed for information retrieval (as a ranking function for search\nengines results), that has also found good use in document classification and clustering.\n:::\n\n::: {.fragment}\nThe idea is that rare words are more informative than common words.  \n\n(This has connections to information theory).\n:::\n\n## Tf-idf Definition\n\nHence, the definition of tf-idf is as follows.\n\nFirst:\n\n$$\n\\text{tf}(t,d) = \\text{Number of times term }t \\text{ occurs in document } d~.\n$$\n\nNext, if $N$ is the total number of documents in the corpus $D$ then:\n\n$$\n\\text{idf}(t,D)=\\log{\\frac{N}{|\\{d\\in D : t\\in d \\}|}},\n$$\n\nwhere the denominator is the number of documents in which the term $t$ appears.\n\nAnd finally:\n\n$$\n\\text{tf-idf}(t,d)=\\text{tf}(t,d)\\times \\text{idf}(t,D).\n$$\n\n::: {#8d980fa1 .cell execution_count=39}\n``` {.python .cell-code}\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nvectorizer = TfidfVectorizer(stop_words = 'english', min_df = 4, max_df = 0.8)\ndata = vectorizer.fit_transform(news_data.data)\n```\n:::\n\n\n## TF-IDF on Newsgroup Data\n\n::: {#aa60a168 .cell execution_count=40}\n``` {.python .cell-code code-fold=\"true\"}\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nimport numpy as np\n\n# Reuse previously loaded 20 Newsgroups subset if available; otherwise load it\ntry:\n    news_data\n    categories\nexcept NameError:\n    from sklearn.datasets import fetch_20newsgroups\n    categories = ['comp.os.ms-windows.misc', 'sci.space', 'rec.sport.baseball']\n    news_data = fetch_20newsgroups(\n        remove=('headers', 'footers', 'quotes'),\n        subset='train',\n        categories=categories,\n        shuffle=True,\n        random_state=42,\n    )\n\n# pick one example document from each category\ndocs_by_cat = []\nlabels = news_data.target\nfor cat_index in range(len(categories)):\n    # first document whose label matches the category index\n    indices = np.where(labels == cat_index)[0]\n    if len(indices) > 0:\n        docs_by_cat.append(news_data.data[indices[0]])\n\n# compute TF-IDF on the selected three documents\ntfidf_vec = TfidfVectorizer(stop_words='english', min_df=1, max_df=1.0)\nX = tfidf_vec.fit_transform(docs_by_cat)\nfeature_names = np.array(tfidf_vec.get_feature_names_out())\n\ndef top_terms(row_vector, k=10):\n    row = row_vector.toarray().ravel()\n    if row.sum() == 0:\n        return []\n    top_idx = np.argsort(row)[-k:][::-1]\n    return list(zip(feature_names[top_idx], row[top_idx]))\n\nfor i, doc in enumerate(docs_by_cat):\n    print(f\"\\nDocument {i+1} (category: {categories[i]}): Top TF-IDF terms\")\n    for term, score in top_terms(X[i], k=10):\n        print(f\"  {term:20s} {score:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nDocument 1 (category: comp.os.ms-windows.misc): Top TF-IDF terms\n  problem              0.2597\n  remember             0.2597\n  win31                0.2597\n  computer             0.2597\n  dos                  0.2597\n  time                 0.1975\n  stacker              0.1298\n  prompt               0.1298\n  defragmented         0.1298\n  thank                0.1298\n\nDocument 2 (category: sci.space): Top TF-IDF terms\n  good                 0.3150\n  canadian             0.2071\n  valentine            0.2071\n  nothin               0.2071\n  old                  0.2071\n  logic                0.2071\n  like                 0.2071\n  rings                0.2071\n  rotation             0.2071\n  say                  0.2071\n\nDocument 3 (category: rec.sport.baseball): Top TF-IDF terms\n  washington           0.3863\n  street               0.3050\n  202                  0.2847\n  dc                   0.2847\n  york                 0.2643\n  212                  0.2643\n  new                  0.2643\n  nw                   0.2440\n  ny                   0.2237\n  news                 0.2033\n```\n:::\n:::\n\n\n## Getting to know the Data\n\n::: {#301b2e2a .cell execution_count=41}\n``` {.python .cell-code}\nprint(f'The datas type is {type(data)} and the shape is {data.shape}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe datas type is <class 'scipy.sparse._csr.csr_matrix'> and the shape is (1781, 6613)\n```\n:::\n:::\n\n\nFor what it's worth we can look at the data feature matrix:\n\n::: {#db6231f2 .cell execution_count=42}\n``` {.python .cell-code}\nfig, ax1 = plt.subplots(1,1,figsize=(8,4))\ndum = sns.heatmap(data[1:100,1:200].todense(), xticklabels=False, yticklabels=False, \n            linewidths=0, cbar=True, ax=ax1)\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-42-output-1.png){width=570 height=328}\n:::\n:::\n\n\n::: {#1f4b65dc .cell execution_count=43}\n``` {.python .cell-code}\nprint(news_data.target)\nprint(news_data.target_names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 0 0 ... 2 1 2]\n['comp.os.ms-windows.misc', 'rec.sport.baseball', 'sci.space']\n```\n:::\n:::\n\n\n## Selecting the Number of Clusters -- Error\n\nNow let's look at the different cluster measures versus number of clusters.\n\n::: {#605e6b15 .cell execution_count=44}\n``` {.python .cell-code}\nerror = evaluate_clusters(data, 10)\nplt.plot(range(1, len(error)), error[1:])\nplt.title('$k$-means Clustering Performance on Newsgroup Articles')\nplt.xlabel('Number of clusters')\nplt.ylabel('Error')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-44-output-1.png){width=825 height=450 fig-align='center'}\n:::\n:::\n\n\n## Selecting the Number of Clusters -- RI\n\n::: {#096fe815 .cell execution_count=45}\n``` {.python .cell-code}\nri, ari = ri_evaluate_clusters(data, 10, news_data.target)\nplt.plot(range(1, len(ari)), ari[1:], 'o-')\nplt.xlabel('Number of clusters')\nplt.title('$k$-means Clustering Compared to Known Labels\\nNewsgroup Articles')\nplt.ylabel('Adjusted Rand Index')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-45-output-1.png){width=821 height=469 fig-align='center'}\n:::\n:::\n\n\n## Selecting the Number of Clusters -- Silhouette Score\n\n::: {#8dc1d879 .cell execution_count=46}\n``` {.python .cell-code}\ns = sc_evaluate_clusters(data, 10, 100, 3)\nplt.plot(range(2, len(s)), s[2:], 'o-')\nplt.xlabel('Number of Clusters')\nplt.title('$k$-means clustering performance on Newsgroup Articles')\nplt.ylabel('Silhouette Score')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-46-output-1.png){width=829 height=450 fig-align='center'}\n:::\n:::\n\n\n## Looking into the clusters\n\nRun $k$-means with 3 clusters:\n\n::: {#cb05aa02 .cell execution_count=47}\n``` {.python .cell-code}\nk = 3\nkmeans = KMeans(n_clusters = k, init = 'k-means++', max_iter = 100, n_init = 25, random_state = 3)\nkmeans.fit_predict(data)\n```\n\n::: {.cell-output .cell-output-display execution_count=195}\n```\narray([2, 0, 0, ..., 2, 2, 2], shape=(1781,), dtype=int32)\n```\n:::\n:::\n\n\nFind the top 10 terms per cluster:\n\n::: {#cf12a56f .cell execution_count=48}\n``` {.python .cell-code}\nasc_order_centroids = kmeans.cluster_centers_.argsort()#[:, ::-1]\norder_centroids = asc_order_centroids[:,::-1]\nterms = vectorizer.get_feature_names_out()\nfor i in range(k):\n    print(f'Cluster {i}:')\n    for ind in order_centroids[i, :10]:\n        print(f' {terms[ind]}')\n    print('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCluster 0:\n windows\n file\n dos\n files\n drivers\n thanks\n card\n driver\n use\n problem\n\nCluster 1:\n year\n game\n team\n games\n runs\n think\n hit\n good\n baseball\n pitching\n\nCluster 2:\n space\n like\n just\n think\n nasa\n know\n don\n thanks\n people\n does\n\n```\n:::\n:::\n\n\n## Pairwise Distances Matrix\n\nLet's calculate the pairwise distances matrix.\n\n::: {#087ce898 .cell execution_count=49}\n``` {.python .cell-code}\neuclidean_dists = metrics.euclidean_distances(data)\nlabels = kmeans.labels_\nidx = np.argsort(labels)\nclustered_dists = euclidean_dists[idx][:,idx]\nfig, ax1 = plt.subplots(1,1,figsize=(6,6))\ndum = sns.heatmap(clustered_dists, xticklabels=False, yticklabels=False, linewidths=0, square=True, cbar=True, ax=ax1)\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-49-output-1.png){width=451 height=471 fig-align='center'}\n:::\n:::\n\n\n## MDS Embedding\n\nLet's visualize with MDS.   \n\nNote that MDS is a slow algorithm and we can't do all 1700+ data points quickly, so we will take a random sample.\n\n::: {#e9d791c1 .cell execution_count=50}\n``` {.python .cell-code}\nimport random\nn_items = euclidean_dists.shape[0]\nrandom.seed(42)\nsubset = random.sample(range(n_items), 500)\n\nfit = mds.fit(euclidean_dists[subset][:, subset])\npos = fit.embedding_\n```\n:::\n\n\nWe have the labels:\n\n::: {#2601765f .cell execution_count=51}\n``` {.python .cell-code}\nlabels\n```\n\n::: {.cell-output .cell-output-display execution_count=199}\n```\narray([2, 0, 0, ..., 2, 2, 2], shape=(1781,), dtype=int32)\n```\n:::\n:::\n\n\n## MDS Embedding\n\n::: {#d6bf6516 .cell execution_count=52}\n``` {.python .cell-code}\ncolorblind_palette = ['#E69F00', '#56B4E9', '#009E73', '#F0E442', '#0072B2']\ncols = [colorblind_palette[l] for l in labels[subset]]\nplt.scatter(pos[:, 0], pos[:, 1], s = 12, c = cols)\nplt.title('MDS Embedding of Newsgroup Articles')\n\nunique_labels = np.unique(labels[subset])\n# Create legend handles and labels based on unique labels\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=colorblind_palette[l], markersize=10) for l in unique_labels]\nlegend_labels = [f'Cluster {l}' for l in unique_labels]\n# Add the legend to the plot\nplt.legend(handles, legend_labels, title='Clusters')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-Clustering-II-in-practice_files/figure-revealjs/cell-52-output-1.png){width=805 height=431 fig-align='center'}\n:::\n:::\n\n\n## Recap and Next\n\nWe've covered:\n\n* How clustering is used in practice\n* Tools for evaluating the quality of a clustering\n* Tools for assigning meaning or labels to a cluster\n* Important visualizations\n* A little bit about feature extraction for text\n\nNext time, we'll look at: \n\n* Hierarchical clustering\n* Gaussian mixture models\n\n",
    "supporting": [
      "07-Clustering-II-in-practice_files"
    ],
    "filters": [],
    "includes": {}
  }
}